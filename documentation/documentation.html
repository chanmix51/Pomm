<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.8.1: http://docutils.sourceforge.net/" />
<title>Pomm Documentation</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7056 2011-06-17 10:50:48Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="pomm-documentation">
<h1 class="title">Pomm Documentation</h1>

<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#overview" id="id4">Overview</a></li>
<li><a class="reference internal" href="#databases-and-converters" id="id5">Databases and converters</a><ul>
<li><a class="reference internal" href="#service-the-database-provider" id="id6">Service: the database provider</a><ul>
<li><a class="reference internal" href="#database-class-and-configuration" id="id7">Database class and configuration</a></li>
<li><a class="reference internal" href="#dsn" id="id8">DSN</a></li>
<li><a class="reference internal" href="#connection-configuration" id="id9">Connection configuration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#converters" id="id10">Converters</a><ul>
<li><a class="reference internal" href="#built-in-converters" id="id11">Built-in converters</a></li>
<li><a class="reference internal" href="#registering-converters" id="id12">Registering converters</a></li>
<li><a class="reference internal" href="#creating-your-own-database-class" id="id13">Creating your own Database class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#converters-and-types" id="id14">Converters and types</a><ul>
<li><a class="reference internal" href="#domains" id="id15">Domains</a></li>
<li><a class="reference internal" href="#composite-types" id="id16">Composite types</a></li>
<li><a class="reference internal" href="#writing-custom-types" id="id17">Writing custom types</a></li>
<li><a class="reference internal" href="#entity-converter" id="id18">Entity converter</a></li>
<li><a class="reference internal" href="#writing-your-own-converters" id="id19">Writing your own converters</a></li>
<li><a class="reference internal" href="#spawning-connections" id="id20">Spawning connections</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#connections" id="id21">Connections</a><ul>
<li><a class="reference internal" href="#id1" id="id22">Overview</a><ul>
<li><a class="reference internal" href="#map-classes-provider" id="id23">Map classes provider</a></li>
<li><a class="reference internal" href="#identity-mappers" id="id24">Identity mappers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#transactions" id="id25">Transactions</a><ul>
<li><a class="reference internal" href="#standard-transactions" id="id26">Standard transactions</a></li>
<li><a class="reference internal" href="#partial-transactions-and-savepoints" id="id27">Partial transactions and savepoints</a></li>
</ul>
</li>
<li><a class="reference internal" href="#prepared-statements" id="id28">Prepared statements</a></li>
<li><a class="reference internal" href="#notifications-and-observers" id="id29">Notifications and observers</a><ul>
<li><a class="reference internal" href="#observers" id="id30">Observers</a></li>
<li><a class="reference internal" href="#sending-a-notification" id="id31">Sending a notification</a></li>
</ul>
</li>
<li><a class="reference internal" href="#logging" id="id32">Logging</a></li>
</ul>
</li>
<li><a class="reference internal" href="#map-classes" id="id33">Map classes</a><ul>
<li><a class="reference internal" href="#id2" id="id34">Overview</a></li>
<li><a class="reference internal" href="#structure" id="id35">Structure</a><ul>
<li><a class="reference internal" href="#introspected-tables" id="id36">Introspected tables</a></li>
<li><a class="reference internal" href="#arrays" id="id37">Arrays</a></li>
<li><a class="reference internal" href="#temporary-tables" id="id38">Temporary tables</a></li>
<li><a class="reference internal" href="#creating-entities" id="id39">Creating entities</a></li>
</ul>
</li>
<li><a class="reference internal" href="#querying-the-database" id="id40">Querying the database</a><ul>
<li><a class="reference internal" href="#create-update-drop" id="id41">Create, update, drop</a></li>
<li><a class="reference internal" href="#built-in-finders" id="id42">Built-in finders</a></li>
<li><a class="reference internal" href="#findall" id="id43">findAll</a></li>
<li><a class="reference internal" href="#findwhere" id="id44">findWhere</a></li>
<li><a class="reference internal" href="#and-or-the-where-class" id="id45">AND, OR: The Where class</a></li>
<li><a class="reference internal" href="#fields-methods" id="id46">Fields methods</a></li>
<li><a class="reference internal" href="#building-custom-queries" id="id47">Building custom queries</a></li>
<li><a class="reference internal" href="#fields-formatters" id="id48">Fields formatters</a></li>
<li><a class="reference internal" href="#complex-queries" id="id49">Complex queries</a></li>
<li><a class="reference internal" href="#virtual-fields" id="id50">Virtual fields</a></li>
</ul>
</li>
<li><a class="reference internal" href="#collections" id="id51">Collections</a><ul>
<li><a class="reference internal" href="#fetching-results" id="id52">Fetching results</a></li>
<li><a class="reference internal" href="#collection-filters" id="id53">Collection filters</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pagers" id="id54">Pagers</a><ul>
<li><a class="reference internal" href="#pager-query-methods" id="id55">Pager query methods</a></li>
<li><a class="reference internal" href="#displaying-a-pager" id="id56">Displaying a pager</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#entities" id="id57">Entities</a><ul>
<li><a class="reference internal" href="#id3" id="id58">Overview</a><ul>
<li><a class="reference internal" href="#what-is-an-entity-class" id="id59">What is an Entity class ?</a></li>
<li><a class="reference internal" href="#data-source-agnostic" id="id60">Data source agnostic</a></li>
<li><a class="reference internal" href="#schema-less-entities" id="id61">Schema less entities</a></li>
</ul>
</li>
<li><a class="reference internal" href="#living-with-entities" id="id62">Living with entities</a><ul>
<li><a class="reference internal" href="#creator" id="id63">Creator</a></li>
<li><a class="reference internal" href="#accessors-and-mutators" id="id64">Accessors and mutators</a></li>
<li><a class="reference internal" href="#interfaces-and-overloads" id="id65">Interfaces and overloads</a></li>
<li><a class="reference internal" href="#extending-entities" id="id66">Extending entities</a></li>
</ul>
</li>
<li><a class="reference internal" href="#entities-and-database" id="id67">Entities and database</a><ul>
<li><a class="reference internal" href="#import-and-export" id="id68">Import and export</a></li>
<li><a class="reference internal" href="#life-cycle" id="id69">Life cycle</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#tools" id="id70">Tools</a><ul>
<li><a class="reference internal" href="#map-generation-tools" id="id71">Map generation tools</a><ul>
<li><a class="reference internal" href="#database-inspector" id="id72">Database Inspector</a></li>
<li><a class="reference internal" href="#createbasemaptool" id="id73">CreateBaseMapTool</a></li>
<li><a class="reference internal" href="#scanschematool" id="id74">ScanSchemaTool</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="overview">
<h1><a class="toc-backref" href="#id4">Overview</a></h1>
<p>Pomm is a fast, lightweight, efficient model manager for Postgresql written in PHP. It can be seen as an enhanced object hydrator above PHP's native Postgresql library with the following features:</p>
<blockquote>
<ul class="simple">
<li>Database Inspector to build automatically your PHP model files (support inheritance).</li>
<li>Postgresql's schemas are mapped to PHP namespaces.</li>
<li>PHP &lt;=&gt; Postgres type converter that support HStore, geometric types, objects, ranges etc.</li>
<li>Lazy fetching for results.</li>
<li>Hydration filters trough PHP callables.</li>
<li>Field selector methods for all SQL queries.</li>
<li>Identity mapper with several different algorithms available.</li>
</ul>
</blockquote>
</div>
<div class="section" id="databases-and-converters">
<h1><a class="toc-backref" href="#id5">Databases and converters</a></h1>
<div class="section" id="service-the-database-provider">
<h2><a class="toc-backref" href="#id6">Service: the database provider</a></h2>
<div class="section" id="database-class-and-configuration">
<h3><a class="toc-backref" href="#id7">Database class and configuration</a></h3>
<p>The <tt class="docutils literal">Service</tt> class just stores the <tt class="docutils literal">Database</tt> instances and provides convenient methods to create connections from them. It is mainly intended to be used with dependency injection containers used by some popular frameworks. The Database class has different roles:</p>
<blockquote>
<ul class="simple">
<li>Connection builder and pool.</li>
<li>Converters holder.</li>
<li>Configuration holder.</li>
</ul>
</blockquote>
<p>It is either possible to instance <cite>Database</cite> class alone or use the <cite>Service</cite> class to do so. The simplest way to get a database instance is:</p>
<pre class="literal-block">
$database = new Pomm\Connection\Database(array(
    'name' =&gt; 'database_name',
    'dsn' =&gt; 'pgsql://user:pass&#64;host:port/db_name'
    ));
</pre>
<p>Database expected parameters are:</p>
<blockquote>
<ul class="simple">
<li>dsn (string, mandatory): Connection string (see <a class="reference internal" href="#dsn">DSN</a>).</li>
<li>name (string, optional, default: physical database name): Logical database name that is used as primary namespace for PHP entity object.</li>
<li>configuration (array, optional, see <a class="reference internal" href="#connection-configuration">Connection configuration</a> below): Client configuration for each connection.</li>
<li>isolation (string, optional, default: <tt class="docutils literal">ISOLATION_READ_COMMITTED</tt>, see <a class="reference internal" href="#standard-transactions">Standard transactions</a>): isolation level used in transactions.</li>
<li>identity_mapper (string, optional, default: <tt class="docutils literal">Smart</tt>, see <a class="reference internal" href="#identity-mappers">Identity mappers</a> below): default identity mapper class name for connections.</li>
</ul>
</blockquote>
<p>There are several ways to declare databases to the service class. Either you use the constructor passing an array &quot;name&quot; =&gt; &quot;connection parameters&quot; or you can use the <tt class="docutils literal">setDatabase()</tt> method of the service class.:</p>
<pre class="literal-block">
# The two examples below are equivalent
# Using the constructor
$service = new Pomm\Service(array(
  'db_one' =&gt; array(
    'dsn' =&gt; 'pgsql://user:pass&#64;host:port/db_a'
  ),
  'db_two' =&gt; array(
    'dsn'   =&gt; 'pgsql://otheruser:hispass&#64;!/path/to/socket/directory!/db_b',
    'class' =&gt; 'App\MyDb',
    'identity_mapper' =&gt; 'App\MyIdentityMapper',
    'name'  =&gt; 'my_db'
  )
  ));

# Using the setDatabase method
$service = new Pomm\Service();
$service-&gt;setDatabase('db_one', new Pomm\Connection\Database(array(
  'dsn' =&gt; 'pgsql://user:pass&#64;host:port/db_a'
)));
$service-&gt;setDatabase('db_two', new App\MyDb(array(
  'dsn' =&gt; 'pgsql://otheruser:hispass&#64;!/path/to/socket/directory!/db_b',
  'identity_mapper' =&gt; 'App\MyIdentityMapper',
  'name'  =&gt; 'my_db'
)));
</pre>
<p>The <em>setDatabase</em> method is used internally by the constructor. Once registered, you can retrieve the databases with their name by calling the <em>getDatabase</em> method passing the name as argument. If no name is given, the first declared <em>Database</em> will be returned.</p>
</div>
<div class="section" id="dsn">
<h3><a class="toc-backref" href="#id8">DSN</a></h3>
<p>The <strong>dsn</strong> parameter format is important because it interacts with Postgresql server's access policy.</p>
<blockquote>
<ul class="simple">
<li><strong>socket connection</strong></li>
<li><tt class="docutils literal"><span class="pre">pgsql://user/database</span></tt> Connect <em>user</em> to the db <em>database</em> without password through the Unix socket system.</li>
<li><tt class="docutils literal"><span class="pre">pgsql://user:pass/database</span></tt> The same but with password.</li>
<li><tt class="docutils literal"><span class="pre">pgsql://user:pass&#64;!/path/to/socket!/database</span></tt> When the socket is not in the default directory, it is possible to specify it in the host part of the DSN. Note it is surrounded by '!' and there are NO ending /. Using the «!» as delimiter assumes there are no «!» in your socket's path. But you don't have «!» in your socket's path do you ?</li>
<li><tt class="docutils literal"><span class="pre">pgsql://user&#64;!/path/to/socket!:port/database</span></tt> Postgresql's listening socket's names are the same as TCP ports. If different than default socket, specify it in the port part.</li>
<li><strong>TCP connection</strong></li>
<li><tt class="docutils literal"><span class="pre">pgsql://user&#64;host/database</span></tt> Connect <em>user</em> to the db <em>database</em> on host <em>host</em> using TCP/IP.</li>
<li><tt class="docutils literal"><span class="pre">pgsql://user:pass&#64;host:port/database</span></tt> The same but with password and TCP port specified.</li>
</ul>
</blockquote>
</div>
<div class="section" id="connection-configuration">
<h3><a class="toc-backref" href="#id9">Connection configuration</a></h3>
<dl class="docutils">
<dt>Connections set client parameters at launch (see <a class="reference external" href="http://www.Postgresql.org/docs/9.3/static/runtime-config-client.html">documentation</a>). Default parameters are the following</dt>
<dd><ul class="first last simple">
<li>bytea_output = escape</li>
<li>intervalstyle = ISO_8601</li>
<li>datestyle = ISO</li>
</ul>
</dd>
</dl>
<p>These parameters are important since the default converters expect client output to be formatted this way. If you change these parameters, register the according converter.</p>
<dl class="docutils">
<dt>Some other parameters can be tuned that way, by default they are set by the server's default configuration:</dt>
<dd><ul class="first last simple">
<li>statement_timeout</li>
<li>lock_timeout</li>
<li>TimeZone</li>
<li>extra_float_digits</li>
</ul>
</dd>
</dl>
</div>
</div>
<div class="section" id="converters">
<h2><a class="toc-backref" href="#id10">Converters</a></h2>
<div class="section" id="built-in-converters">
<h3><a class="toc-backref" href="#id11">Built-in converters</a></h3>
<p>The <tt class="docutils literal">Database</tt> class brings access to mechanisms to create connections and also to register converters. A <tt class="docutils literal">Converter</tt> is a class that translates a data type between PHP and Postgresql.</p>
<dl class="docutils">
<dt>By default, the following converters are registered, this means you can use them without configuring anything:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal">Boolean</tt>: convert Postgresql booleans 't' and 'f' to/from PHP boolean values</li>
<li><tt class="docutils literal">Number</tt>: convert Postgresql 'smallint', 'bigint', 'integer', 'decimal', 'numeric', 'real', 'double precision', 'serial', 'bigserial' types to numbers</li>
<li><tt class="docutils literal">String</tt>: convert Postgresql 'varchar', 'char', 'bpchar', 'uuid', 'tsvector', 'xml', 'json' (Pg 9.2), 'name' and 'text' into PHP string</li>
<li><tt class="docutils literal">Timestamp</tt>: convert Postgresql 'timestamp', 'date', 'time' to PHP <tt class="docutils literal">DateTime</tt> instance.</li>
<li><tt class="docutils literal">Interval</tt>: convert Postgresql's 'interval' type into PHP <tt class="docutils literal">DateInterval</tt> instance.</li>
<li><tt class="docutils literal">Binary</tt>: convert Postgresql's 'bytea' type into PHP binary string.</li>
<li><tt class="docutils literal">Array</tt>: convert Postgresql arrays from/to PHP arrays.</li>
<li><tt class="docutils literal">TsRange</tt>: convert Postgresql 'tsrange', 'daterange' to <tt class="docutils literal">\Pomm\Type\TsRange</tt> instance (Pg 9.2).</li>
<li><tt class="docutils literal">NumberRange</tt>: convert Postgresql 'int4range', 'int8range', 'numrange` into <tt class="docutils literal">\Pomm\Type\NumberRange</tt> instance (Pg 9.2).</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="registering-converters">
<h3><a class="toc-backref" href="#id12">Registering converters</a></h3>
<dl class="docutils">
<dt>Other types are natively available in Postgresql but are not loaded automatically at startup by Pomm.</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal">Point</tt>: convert Postgresql 'point' representation as <tt class="docutils literal">Pomm\Type\Point</tt> instance.</li>
<li><tt class="docutils literal">Segment</tt>: convert 'segment' representation as <tt class="docutils literal">Pomm\Type\Segment</tt>.</li>
<li><tt class="docutils literal">Circle</tt>: 'convert circle' representation as <tt class="docutils literal">Pomm\Type\Circle</tt>.</li>
</ul>
</dd>
</dl>
<p>Postgresql contribs come with handy extra data type (like HStore, a key =&gt; value array and LTree a materialized path data type). If you use these types in your database you have to register the according converters from your database instance:</p>
<pre class="literal-block">
$database-&gt;registerConverter('HStore', new Pomm\Converter\PgHStore(), array('public.hstore'));
</pre>
<dl class="docutils">
<dt>Arguments to instantiate a <tt class="docutils literal">Converter</tt> are the following:</dt>
<dd><ul class="first last simple">
<li>the first argument is the converter name.</li>
<li>the second argument is the instance of the <tt class="docutils literal">Converter</tt></li>
<li>the third argument is a Postgresql type or a set of types for Pomm to link them with the given converter.</li>
</ul>
</dd>
</dl>
<p>Although Postgresql native types are stored in an internal schema hence are reachable from everywhere without mention to fully qualified name, user defined types and extensions definitions are stored in user schemas (by default <tt class="docutils literal">public</tt>). It is advised to provide the fqn for user defined types and extensions.</p>
</div>
<div class="section" id="creating-your-own-database-class">
<h3><a class="toc-backref" href="#id13">Creating your own Database class</a></h3>
<p>If your database has a lot of custom types, it is a good idea to create your own <tt class="docutils literal">Database</tt> class.:</p>
<pre class="literal-block">
class MyDatabase extends Pomm\Connection\Database
{
  protected function initialize()
  {
    parent::initialize();

    $this-&gt;registerConverter('HStore',
      new Pomm\Converter\Hstore(), array('hstore'));

    $this-&gt;registerConverter('Point',
      new Pomm\Converter\Pgpoint(), array('point'));

    $this-&gt;registerConverter('Circle',
      new Pomm\Converter\PgCircle(), array('circle'));
  }
}
</pre>
<p>This way, converters will be automatically registered at instantiation.</p>
</div>
</div>
<div class="section" id="converters-and-types">
<h2><a class="toc-backref" href="#id14">Converters and types</a></h2>
<div class="section" id="domains">
<h3><a class="toc-backref" href="#id15">Domains</a></h3>
<p>In case your database uses <tt class="docutils literal">DOMAIN</tt> types, you can associate them with an already registered converter. The <tt class="docutils literal">registerTypeForConverter()</tt> method stands for that.:</p>
<pre class="literal-block">
$database
  -&gt;registerTypeForConverter('public.email_address', 'String');
</pre>
<p>In the example above, the database contains a domain <tt class="docutils literal">email_address</tt> which is a subtype of <tt class="docutils literal">varchar</tt> so it is associated with the built-in converter <tt class="docutils literal">String</tt>.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal">registerTypeForConverter</tt> and <tt class="docutils literal">registerConverter</tt> methods implement the fluid interface so you can chain calls.</p>
</div>
</div>
<div class="section" id="composite-types">
<h3><a class="toc-backref" href="#id16">Composite types</a></h3>
<p>Composite types are particularly useful to store complex set of data and store them as they were objects:</p>
<pre class="literal-block">
CREATE TYPE postal_address AS (place text, postal_code char(5), city varchar, cedex char);

CREATE TABLE customer (
    customer_id uuid PRIMARY KEY,
    ...,
    billing_address postal_address NOT NULL CHECK
        ((billing_address).place IS NOT NULL AND (billing_address).city IS NOT NULL AND (billing_address).postal_code IS NOT NULL)
</pre>
<p>If such types exist in your database, they must be registered so Pomm can convert them to an according array using the <tt class="docutils literal">PgRow</tt> converter:</p>
<pre class="literal-block">
$database-&gt;registerConverter(
    'PostalAddress',
    new \Pomm\Converter\PgRow(
        $database,
        new \Pomm\Object\RowStructure(array('place' =&gt; 'text', 'postal_code' =&gt; 'char', 'city' =&gt; 'varchar', 'cedex' =&gt; 'char'))
        ),
    array('public.postal_address')
    ;
</pre>
<p>This way, the composite types can be used as is in the map classes:</p>
<pre class="literal-block">
protected function intitialize()
{
    parent::intialize();

    $this-&gt;addField('customer_id', 'uuid')
        ...
        -&gt;addField('billing_address', 'public.postal_address')
        ...
        ;
</pre>
<p>This will store, in a field named <tt class="docutils literal">billing_address</tt> an array formatted with the given attributes. It is important to understand they must be used like fixed arrays, this means all keys must be filled even if the value is NULL to save the entity:</p>
<pre class="literal-block">
$entity['billing_address'] = array('place' =&gt; 'some_place', 'postal_code' =&gt; '44000', 'city' =&gt; 'Nantes');
$map-&gt;saveOne($entity);
</pre>
<p>This will throw an exception since the <tt class="docutils literal">cedex</tt> key is missing.</p>
</div>
<div class="section" id="writing-custom-types">
<h3><a class="toc-backref" href="#id17">Writing custom types</a></h3>
<p>One solution to prevent the problem presented above is to use objects instead of arrays. The converter accepts a third argument <tt class="docutils literal">class_name</tt> that will spawn an instance from the array if set:</p>
<pre class="literal-block">
$database-&gt;registerConverter(
    'PostalAddress',
    new \Pomm\Converter\PgRow(
        $database,
        new \Pomm\Object\RowStructure(array('place' =&gt; 'text', 'postal_code' =&gt; 'char', 'city' =&gt; 'varchar', 'cedex' =&gt; 'char')),
        '\Namespace\Of\Type\Address' // &lt;- provide a class name here
        ),
    array('public.postal_address')
    ;
</pre>
<p>The <tt class="docutils literal">Address</tt> class is simplistic, since it must be a fixed typed class, it may just extends <tt class="docutils literal">\Pomm\Type\Composite</tt> and declare attributes as public:</p>
<pre class="literal-block">
class Address extends \Pomm\Type\Composite
{
    public $place;
    public $postal_code;
    public $city;
    public $cedex;
}
</pre>
<div class="warning">
<p class="first admonition-title">Warning</p>
<p class="last">It is important that the attibutes be public so the values can easily be extracted into an array during the conversion process. Protected and private attributes will be ignored by the converter.</p>
</div>
<p>This type can directly be used with the entities:</p>
<pre class="literal-block">
$entity['billing_address'] = new \Namespace\Of\Type\Address(array('place' =&gt; 'some_place', 'postal_code' =&gt; '44000', 'city' =&gt; 'Nantes'));
</pre>
<p>This is useful in many ways, one of them being the ability to code proper accessors for the composite type instance.</p>
</div>
<div class="section" id="entity-converter">
<h3><a class="toc-backref" href="#id18">Entity converter</a></h3>
<p>In Postgresql, creating a table means creating a new type with the table's fields definition. Hence, it is possible to use that data type in other tables or use them as objects in your SQL queries. Pomm proposes a special converter to do so: the <tt class="docutils literal">PgEntity</tt> converter. Passing the table data type name and the associated entity class name will grant you with embedded entities.</p>
<pre class="literal-block">
$database
  -&gt;registerConverter('MyEntity', new \Pomm\Converter\PgEntity($my_entity_map), array('my_schema.my_entity));
</pre>
</div>
<div class="section" id="writing-your-own-converters">
<h3><a class="toc-backref" href="#id19">Writing your own converters</a></h3>
<dl class="docutils">
<dt>All converters must implement the <tt class="docutils literal">Pomm\Converter\ConverterInterface</tt>. This interface makes converters to have two methods:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">fromPg($data,</span> $type)</tt>: converts string data fetched from a Postgresql result to a PHP representation.</li>
<li><tt class="docutils literal"><span class="pre">toPg($data,</span> $type)</tt>: converts PHP data representation to a string that will be used in a SQL query.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="spawning-connections">
<h3><a class="toc-backref" href="#id20">Spawning connections</a></h3>
<p>Database instances are also connections provider trough two methods:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal">createConnection()</tt> force the creation of a new connection.</li>
<li><tt class="docutils literal">getConnection()</tt> return an existing <tt class="docutils literal">Connection</tt> instance if any, create it otherwise.</li>
</ul>
</blockquote>
<p>It is important to understand that connections hold a lot of context (entity caching trough the mapper, prepared statements etc.), enforce the creation of a new connection set up a new bare context. The most common way to get a connection is:</p>
<pre class="literal-block">
$connection = $database-&gt;getConnection();
</pre>
</div>
</div>
</div>
<div class="section" id="connections">
<h1><a class="toc-backref" href="#id21">Connections</a></h1>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id22">Overview</a></h2>
<dl class="docutils">
<dt>A connection represents a link to the database. It owns several responsibilities:</dt>
<dd><ul class="first last simple">
<li>Map classes provider</li>
<li>Identity mapper</li>
<li>Prepared statements pooling</li>
<li>Transactions handling</li>
<li>Queries execution</li>
<li>Logger handling</li>
</ul>
</dd>
</dl>
<p>Connections are lazy. This means unless a communication is needed with the database server, no sessions are open.</p>
<div class="section" id="map-classes-provider">
<h3><a class="toc-backref" href="#id23">Map classes provider</a></h3>
<p>Connections are a pool of map instances. This way, a connection will always provide the same instance for the same map class:</p>
<pre class="literal-block">
$student_map = $connection-&gt;getMapFor('College\School\Student');
</pre>
</div>
<div class="section" id="identity-mappers">
<h3><a class="toc-backref" href="#id24">Identity mappers</a></h3>
<p>Connections are also the way to tell the map classes to use or not an <tt class="docutils literal">IdentityMapper</tt>. An identity mapper is an index kept by the connection and shared amongst the map instances. This index ensures that when an object is retrieved twice from the database, the same <tt class="docutils literal">Object</tt> instance will be returned. This is a very powerful (and dangerous) feature.</p>
<dl class="docutils">
<dt>There are two ways to declare an identity mapper to your connections:</dt>
<dd><ul class="first simple">
<li>in the <tt class="docutils literal">Database</tt> parameters. All the connections created for this database will use the given <tt class="docutils literal">IdentityMapper</tt> class.</li>
<li>when instanciating the connection through the <tt class="docutils literal">createConnection()</tt> call. This enforces the parameter given to the <tt class="docutils literal">Database</tt> class if any.</li>
</ul>
<pre class="last literal-block">
$map = $database()
  -&gt;createConnection(new \Pomm\Identity\IdentityMapperSmart())
  -&gt;getMapFor('College\School\Student');

$student1 = $map-&gt;findByPK(array('id' =&gt; 3));
$student2 = $map-&gt;findByPK(array('id' =&gt; 3));

$student1-&gt;setName('plop');
echo $student2-&gt;getName();    // plop
</pre>
</dd>
<dt>It is often a good idea to have an identity mapper by default, but in some cases you will want to switch it off and ensure all objects you fetch from the database do not come from the mapper. This is possible passing the <tt class="docutils literal">Connection</tt> an instance of <tt class="docutils literal">IdentityMapperNone</tt>. It will never keep any instances. There are two other types of identity mappers:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal">IdentityMapperStrict</tt> which always return an instance if it is in the index.</li>
<li><tt class="docutils literal">IdentityMapperSmart</tt> which checks if the instance has not been deleted. If data are fetched from the db, it checks if the instance kept in the index has not been modified. If not, it merges the fetched values with its instance.</li>
</ul>
</dd>
</dl>
<p>It is of course always possible to remove an instance from the mapper by calling the <tt class="docutils literal">removeInstance()</tt>. You can create your own identity mapper, just make sure your class implement the <tt class="docutils literal">IdentityMapperInterface</tt>. Be aware the mapper is called for each values fetched from the database so it has a real impact on performances.</p>
<p><strong>Important</strong> The identity mappers strict and smart rely on the use of primary keys to identify records. If you use a table without primary keys, these identity mappers will <strong>NOT</strong> store any of these entities.</p>
</div>
</div>
<div class="section" id="transactions">
<h2><a class="toc-backref" href="#id25">Transactions</a></h2>
<div class="section" id="standard-transactions">
<h3><a class="toc-backref" href="#id26">Standard transactions</a></h3>
<p>By default, connections are in auto-commit mode which means every change in the database is committed on the fly. Connections offer the way to enter in transaction mode:</p>
<pre class="literal-block">
$connection-&gt;begin();

try
{
    # do things here
    $connection-&gt;commit();
}
catch (Pomm\Exception\Exception $e)
{
    $connection-&gt;rollback();
}
</pre>
<p>The transaction type is determined by <tt class="docutils literal">ISOLATION LEVEL</tt> you set in your connection's parameters (see <a class="reference internal" href="#database-class-and-configuration">Database class and configuration</a>)</p>
<p>Isolation level must be one of <tt class="docutils literal"><span class="pre">Pomm\Connection\Connection::ISOLATION_READ_COMMITTED</span></tt>, <tt class="docutils literal">ISOLATION_READ_REPEATABLE</tt> or <tt class="docutils literal">ISOLATION_SERIALIZABLE</tt>. Check your Postgresql version for the available levels. Starting from pg 9.1, what was called <tt class="docutils literal">SERIALIZABLE</tt> is called <tt class="docutils literal">READ_REPEATABLE</tt> and <tt class="docutils literal">SERIALIZABLE</tt> is a race for the first transaction to COMMIT. This means if the transaction fails, you may just try again until it works. Check the <a class="reference external" href="http://www.Postgresql.org/docs/9.1/static/transaction-iso.html">Postgresql documentation</a> about transactions for details.</p>
</div>
<div class="section" id="partial-transactions-and-savepoints">
<h3><a class="toc-backref" href="#id27">Partial transactions and savepoints</a></h3>
<p>Sometime, you may need to split transactions into parts and be able to perform partial rollback. Postgresql lets you use save points in your transaction:</p>
<pre class="literal-block">
$connection-&gt;begin();
try
{
    # do things here
}
catch (Pomm\Exception\Exception $e)
{
    // The whole transaction is rolled back
    $connection-&gt;rollback();
    throw $e;
}
$connection-&gt;setSavepoint('A');
try
{
    # do other things
}
catch (Pomm\Exception\Exception $e)
{
    // only statments after savepoint A are rolled back
    $connection-&gt;rollback('A');
}
$connection-&gt;commit();
</pre>
</div>
</div>
<div class="section" id="prepared-statements">
<h2><a class="toc-backref" href="#id28">Prepared statements</a></h2>
<p>Connections are a pool of prepared statements. Every time a query is sent to the server, it is prepared, executed and stored until the connection is shut down. This way, if a query is issued a second time, the statement does not need to be parsed again. It is somehow possible to use them directly:</p>
<pre class="literal-block">
$sql = &quot;SELECT field1, ..., fieldX FROM some_table WHERE a_field &gt; $* AND another_field &#64;&gt; $*;&quot;
$query = $connection-&gt;createPreparedQuery($sql);

$collection_1 = $query-&gt;execute(array($value01, $value02));
$collection_2 = $query-&gt;execute(array($value11, $value12));
</pre>
<p>Note the placeholder for values to be escaped is the symbol <tt class="docutils literal">$*</tt>. This is different from what is to be used with PHP pgsql library and also different from PDO placeholders. The problem with PHP native pgsql library is the placeholders are in the form <tt class="docutils literal">$n</tt> where n is the position. Using positional parameters is a pain when building queries because the position of the parameters you may add is not known. PDO's placeholders is the <tt class="docutils literal">?</tt>. This conflicts with some operators in Postgresql. If you migrate from an existing project to Pomm, queries must be checked to be compliant with the <tt class="docutils literal">$*</tt> placeholder.</p>
</div>
<div class="section" id="notifications-and-observers">
<h2><a class="toc-backref" href="#id29">Notifications and observers</a></h2>
<dl class="docutils">
<dt>Aside the transaction engine, Postgresql proposes an asynchronous messaging system. To benefit from this useful feature, Pomm's connection let the possibility to spawn observers and to trigger events using the following methods:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal">createObserver()</tt></li>
<li><tt class="docutils literal">notify()</tt></li>
</ul>
</dd>
</dl>
<div class="section" id="observers">
<h3><a class="toc-backref" href="#id30">Observers</a></h3>
<p><tt class="docutils literal">createObserver()</tt> returns an <tt class="docutils literal">Observer</tt> instance. This instance can listen to a given event and return the payload if any when an event is triggered:</p>
<pre class="literal-block">
$observer = $connection
    -&gt;createObserver()
    -&gt;listen('an_event');

while(!$data = $observer-&gt;getNotification())
{
    sleep(SOME_TIME)
}

$payload = $data['payload']; // payload if any
</pre>
</div>
<div class="section" id="sending-a-notification">
<h3><a class="toc-backref" href="#id31">Sending a notification</a></h3>
<p>To trigger a notification to observers, use the <tt class="docutils literal">notify()</tt> method:</p>
<pre class="literal-block">
$connection-&gt;notify('an_event', 'a payload');
</pre>
</div>
</div>
<div class="section" id="logging">
<h2><a class="toc-backref" href="#id32">Logging</a></h2>
<p>Connections can register any logger class that implements <tt class="docutils literal">\Psr\Logger\LoggerInterface</tt> using the <tt class="docutils literal">setLogger()</tt> method.</p>
<p>All exceptions will be logged using <tt class="docutils literal">ERROR</tt> level. Connecting problems will issue a <tt class="docutils literal">ALERT</tt> level log message.</p>
</div>
</div>
<div class="section" id="map-classes">
<h1><a class="toc-backref" href="#id33">Map classes</a></h1>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id34">Overview</a></h2>
<dl class="docutils">
<dt>Map classes are the central point of Pomm because</dt>
<dd><ul class="first last simple">
<li>they are a bridge between the database and entities</li>
<li>they own the structure of their corresponding entities</li>
<li>They act as entity providers</li>
</ul>
</dd>
</dl>
<p>Every action you will perform with your entities will use a Map class. They are roughly the equivalent of Propel's <em>Peer</em> classes or Doctrine's repositories. Although it might looks like Propel, it is important to understand unlike the normal Active Record design pattern, entities do not even know their structure and how to save themselves. You have to use their relative Map class to save them.</p>
<p>Map classes represent a structure in the database and provide methods to retrieve and save data with this structure. To be short, one table or view =&gt; one map class.</p>
<p>To create the link between a database and entities, all Map classes <strong>must</strong> at the end extends <tt class="docutils literal">\Pomm\Object\BaseObjectMap</tt>. This class implements methods that directly interact with the database using the PDO layer. These methods will be explained in the chapter <a class="reference internal" href="#querying-the-database">Querying the database</a>.</p>
<dl class="docutils">
<dt>The structure of the map classes can be automatically guessed from the database hence it is possible to generate the structure part of the map files from the command line (see below). If these classes can be generated, it is advisable not to modify them by hand because modifications would be lost at the next generation. This is why Map classes are split using inheritance:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal">BaseYourEntityMap</tt> which are abstract classes inheriting from <tt class="docutils literal">\Pomm\Object\BaseObjectMap</tt></li>
<li><tt class="docutils literal">YourEntityMap</tt> inheriting from <tt class="docutils literal">BaseYourEntityMap</tt>.</li>
</ul>
</dd>
</dl>
<p><tt class="docutils literal">BaseYourEntityMap</tt> can be skipped but since Pomm proposes automatic code generation, this file can be regenerated over and over without you to loose precious custom code. This is why this file owns the data structure read from the database. If you create a map file that does not rely on automatic generation, it has not not to use a BaseMap file.</p>
</div>
<div class="section" id="structure">
<h2><a class="toc-backref" href="#id35">Structure</a></h2>
<div class="section" id="introspected-tables">
<h3><a class="toc-backref" href="#id36">Introspected tables</a></h3>
<dl class="docutils">
<dt>When Map classes are instantiated, the method <tt class="docutils literal">initialize</tt> is triggered. This method is responsible of setting various structural elements:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal">object_name</tt>: the related table name</li>
<li><tt class="docutils literal">object_class</tt>: the related entity's fully qualified class name</li>
<li><tt class="docutils literal">field_structure</tt>: the fields with their corresponding Postgresql type</li>
<li><tt class="docutils literal">primary_key</tt>: an array with simple or composite primary key</li>
</ul>
</dd>
</dl>
<p>If the table is stored in a special database schema, it must appear in the <tt class="docutils literal">object_name</tt> attribute. If you do not use schemas, Postgresql will store everything in the public schema. You do not have to specify it in the <tt class="docutils literal">object_name</tt> attribute but it will be used in the class namespace. As <tt class="docutils literal">public</tt> is also a reserved keyword of PHP, the namespace for the public schema is <tt class="docutils literal">PublicSchema</tt>.</p>
<p>Let's say we have the following table <tt class="docutils literal">student</tt> in the <tt class="docutils literal">public</tt> schema of the database <tt class="docutils literal">college</tt>:</p>
<pre class="literal-block">
+-------------+-------------------------------+
|   Column    |            Type               |
+=============+===============================+
|  reference  | character(10)                 |
+-------------+-------------------------------+
|  first_name | character varying             |
+-------------+-------------------------------+
|  last_name  | character varying             |
+-------------+-------------------------------+
|  birthdate  | timestamp without time zone   |
+-------------+-------------------------------+
|  level      | smallint                      |
+-------------+-------------------------------+
|  exam_dates | timestamp without time zone[] |
+-------------+-------------------------------+
</pre>
<p>The last field <tt class="docutils literal">exam_dates</tt> is an array of timestamps (see <a class="reference internal" href="#arrays">Arrays</a> below). The corresponding PHP structure will be:</p>
<pre class="literal-block">
&lt;?php

 namespace College\PublicSchema\Base;

 use Pomm\Object\BaseObjectMap;
 use Pomm\Exception\Exception;

 abstract class StudentMap extends BaseObjectMap
 {
     public function initialize()
     {
         $this-&gt;object_class =  '\College\PublicSchema\Student';
         $this-&gt;object_name  =  'student';

         $this-&gt;addField('reference', 'char');
         $this-&gt;addField('first_name', 'varchar');
         $this-&gt;addField('last_name', 'varchar');
         $this-&gt;addField('birthdate', 'timestamp');
         $this-&gt;addField('level', 'smallint');
         $this-&gt;addField('exam_dates', 'timestamp[]');

         $this-&gt;pk_fields = array('reference');
     }
 }
</pre>
<p>All generated map classes use PHP namespace. This namespace is composed by the database name and the database schema the table is located in. If database name is not supplied to the <tt class="docutils literal">Database</tt> constructor (see <a class="reference internal" href="#database-class-and-configuration">Database class and configuration</a>), the real database name is used. If by example, the previous table were in the <tt class="docutils literal">school</tt> database schema, the following lines would change:</p>
<pre class="literal-block">
&lt;?php

 namespace College\School\Base;
 ...
         $this-&gt;object_class =  'College\School\Student';
         $this-&gt;object_name  =  'school.student';
</pre>
</div>
<div class="section" id="arrays">
<h3><a class="toc-backref" href="#id37">Arrays</a></h3>
<p>Postgresql supports arrays. An array can contain several data all from the same type. Pomm of course supports this feature using the <tt class="docutils literal">[]</tt> notation after the converter declaration:</p>
<pre class="literal-block">
$this-&gt;addField('authors', 'varchar[]');   // Array of strings
$this-&gt;addField('locations', 'point[]');   // Array of points
</pre>
<p>The converter system handles that and the entities will be hydrated with an array of the according type depending on the given converter.</p>
</div>
<div class="section" id="temporary-tables">
<h3><a class="toc-backref" href="#id38">Temporary tables</a></h3>
<p>Sometimes, you might want to create temporary tables. A map class can create its own table, modify it and destroy it. Let's imagine we have to create a temporary tables for students and their average scores in each discipline. The following map class could do the job:</p>
<pre class="literal-block">
&lt;?php

namespace College\School;

use Pomm\Object\BaseObjectMap;
use Pomm\Object\BaseObject;
use Pomm\Query\Where;

class AverageStudentScoreMap extends BaseObjectMap
{
    public function initialize()
    {
      $this-&gt;object_class =  'College\School\AverageStudentScore';
      $this-&gt;object_name  =  'school.average_student_score';

      $this-&gt;addField('reference', 'varchar');
      $this-&gt;addField('maths', 'numeric');
      $this-&gt;addField('physics', 'numeric');
      ...
    }

    public function createTable()
    {
      $sql = &quot;CREATE TEMPORARY TABLE %s (reference VARCHAR PRIMARY KEY, ...

      $this-&gt;query(sprintf($sql, $this-&gt;getTableName()), array());
    }

    public function dropTable()
    {
      $sql = &quot;DROP TABLE %s CASCADE&quot;;

      $this-&gt;query(sprintf($sql, $this-&gt;getTableName()), array());
    }
}
</pre>
<p>You can create methods to change the table structure, add or drop columns etc. This is what it is done by example in the converter test script.</p>
</div>
<div class="section" id="creating-entities">
<h3><a class="toc-backref" href="#id39">Creating entities</a></h3>
<p>Map instances are entities builder, it is possible to create entities and save them in the same move:</p>
<pre class="literal-block">
$entity = $map-&gt;createObject(array('field1' =&gt; $value1, ...)); // This build an entity instance.
$entity = $map-&gt;createAndSaveObject(array('field1' =&gt; $value1, ...)); // This build and save an entity.
$collection = $map-&gt;createAndSaveObjects(array(array('field1' =&gt; $value01, ...), array('field1' =&gt; $value11, ...))); // Save entities and return a collection.
</pre>
<p>These methods are useful to push new data in the database but sometimes, data collected from the interface are not enough to save a database entity. This is the case when some values rely on Postgresql functions. The <tt class="docutils literal">RawString</tt> type allow programmers to pass unescaped strings to the database:</p>
<pre class="literal-block">
$entity = $map-&gt;createAndSaveObject(array('field' =&gt; new \Pomm\Type\RawString('my_pg_function(...)')));
</pre>
<p>This will issue an insert statement like:</p>
<pre class="literal-block">
INSERT INTO some_table (field) VALUES (my_pg_function(...)) RETURNING ...
</pre>
</div>
</div>
<div class="section" id="querying-the-database">
<h2><a class="toc-backref" href="#id40">Querying the database</a></h2>
<div class="section" id="create-update-drop">
<h3><a class="toc-backref" href="#id41">Create, update, drop</a></h3>
<p>The main goal of the map classes is to provide a layer between a database and entities. They provide programmers with basic tools to save, update and delete entities trough <tt class="docutils literal">saveOne()</tt>, <tt class="docutils literal">updateOne()</tt> and <tt class="docutils literal">deleteOne()</tt> methods.</p>
<pre class="literal-block">
$entity = $map-&gt;createObject(array('pika' =&gt; 'chu', 'plop' =&gt; false));

$map-&gt;saveOne($entity);     // INSERT

$entity-&gt;setPika('no');
$entity-&gt;setPlop(true);

$map-&gt;saveOne($entity);     // UPDATE
</pre>
<p>As illustrated above, the <tt class="docutils literal">saveOne()</tt> method saves an entity whatever it is an update or an insert. It is important to know that the internal state (see <a class="reference internal" href="#life-cycle">Life cycle</a>) of the entity is used to determine if the object exists or not and choose between the <tt class="docutils literal">INSERT</tt> or the <tt class="docutils literal">UPDATE</tt> statement.
Whatever is used, the whole structure is saved every time this method is called. In order just to update some fields, use the <tt class="docutils literal">updateOne()</tt> method.</p>
<div class="warning">
<p class="first admonition-title">Warning</p>
<p class="last">If the table related to this entity sets default values (like <tt class="docutils literal">created_at</tt> field by example) they will be <strong>automatically hydrated in the entity</strong>.</p>
</div>
<pre class="literal-block">
$entity-&gt;setPika('chu');
$entity-&gt;setPlop(false);

$map-&gt;updateOne($entity, array('pika')); // UPDATE ... set pika='...'

$map-&gt;getPika();            // chu
$map-&gt;getPlop();            // true
</pre>
<p>In the example above, two fields are set and only one is updated. The result of this is the second field to be <strong>replaced with the value from the database</strong>.</p>
<pre class="literal-block">
$map-&gt;deleteOne($entity);

$entity-&gt;isNew();           // false
$entity-&gt;isModified();        // false
</pre>
<p>The <tt class="docutils literal">deleteOne()</tt> method is pretty straightforward. Like the other modifiers, it hydrates the entity with the deleted row from the database in case there are to be used elsewhere.</p>
</div>
<div class="section" id="built-in-finders">
<h3><a class="toc-backref" href="#id42">Built-in finders</a></h3>
<p>The first time the base map classes are generated, the map classes and the entity classes will be also created. Using the example with student, the empty map file should look like this:</p>
<pre class="literal-block">
&lt;?php
namespace College\School;

use College\School\Base\StudentMap as BaseStudentMap;
use Pomm\Exception\Exception;
use Pomm\Query\Where;
use College\School\Student;

class StudentMap extends BaseStudentMap
{
}
</pre>
<p>This is the place other finders are going to take place. As it extends <tt class="docutils literal">BaseObjectMap</tt> via <tt class="docutils literal">BaseStudentMap</tt> it already has some useful finders:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">findAll(...)</span></tt> return all entities</li>
<li><tt class="docutils literal"><span class="pre">findByPK(...)</span></tt> return a single entity</li>
<li><tt class="docutils literal"><span class="pre">findWhere(...)</span></tt> perform a <tt class="docutils literal">SELECT ... FROM my.table WHERE ...</tt></li>
</ul>
</blockquote>
<p>Finders return either a <tt class="docutils literal">Collection</tt> instance virtually containing all entities returned by the query (see <a class="reference internal" href="#collections">Collections</a>) or just a related model entity instance (like <tt class="docutils literal">findByPK</tt>).</p>
</div>
<div class="section" id="findall">
<h3><a class="toc-backref" href="#id43">findAll</a></h3>
<p><tt class="docutils literal">findAll</tt> is the simplest query that can be issued on a database set, it returns all the tuples of the set. This method takes a query suffix as optional argument. This is useful for query modifiers like <tt class="docutils literal">LIMIT ... OFFSET</tt> or <tt class="docutils literal">ORDER BY</tt>.</p>
<pre class="literal-block">
$map-&gt;findAll('ORDER BY created_at DESC LIMIT 5');

// corresponding query
SELECT
  &quot;field1&quot; AS &quot;field1&quot;,
  ...
FROM
  table_name
ORDER BY created_at DESC LIMIT 5
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">If you are just interested by the suffix to paginate your queries, have a look at <cite>Pagers_</cite>.</p>
</div>
</div>
<div class="section" id="findwhere">
<h3><a class="toc-backref" href="#id44">findWhere</a></h3>
<p>The simplest way to create a query with Pomm is to use the <tt class="docutils literal">findWhere()</tt> method.</p>
<dl class="docutils">
<dt>findWhere($where, $values, $suffix)</dt>
<dd>returns a set of entities based on the given where clause. This clause can be a string or a <tt class="docutils literal">Where</tt> instance.</dd>
</dl>
<p>It is possible to use it directly because we are in a Map class hence Pomm knows what table and fields to use in the query.</p>
<pre class="literal-block">
/* SELECT
     reference,
     first_name,
     last_name,
     birthdate
   FROM
     shool.student
   WHERE
       birthdate &gt; '1980-01-01
     AND
       first_name ILIKE '%an%'
*/

// don't do that !
$students = $this-&gt;findWhere(&quot;birthdate &gt; '1980-01-01' AND first_name ILIKE '%an%'&quot;);
</pre>
<p>Of course, this is not very useful, because the date is very likely to be a parameter. A finder <tt class="docutils literal">getYoungerThan</tt> would be:</p>
<pre class="literal-block">
public function getYoungerThan(DateTime $date)
{
/* SELECT
     reference,
     first_name,
     last_name,
     birthdate
   FROM
     shool.student
   WHERE
       birthdate &gt; $date
     AND
       first_name ILIKE '%an%'
   ORDER BY
     birthdate DESC
   LIMIT 10
*/

  return $this-&gt;findWhere(&quot;birthdate &gt; $* AND first_name ILIKE $*&quot;,
      array($date, '%an%'),
      'ORDER BY birthdate DESC LIMIT 10'
      );
}
</pre>
<p>All queries are prepared, this might increase the performance but it certainly increases the security. Passing the argument using the question mark makes it automatically to be escaped by the database and avoid SQL-injection attacks. If a suffix is passed, it is appended to the query <strong>as is</strong>. The suffix is intended to allow developers specifying the sorting order of a subset. As the query is prepared, a multiple query injection type attack is not directly possible but be careful if the values sent directly from an untrusted source.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The DateTime PHP instances can be passed as is, they will be converted into string internally.</p>
</div>
</div>
<div class="section" id="and-or-the-where-class">
<h3><a class="toc-backref" href="#id45">AND, OR: The Where class</a></h3>
<p>Sometimes, it is not possible to know in advance what will be the clauses of your query because it depends on variable factors. The <tt class="docutils literal">Where</tt> class chains logical statements:</p>
<pre class="literal-block">
public function getYoungerThan(DateTime $date, $needle)
{
  $where = new Pomm\Query\Where(&quot;birthdate &gt; $*&quot;, array($date));
  $where-&gt;andWhere('first_name ILIKE $*', array(sprintf('%%%s%%', $needle)));

  return $this-&gt;findWhere($where, null, 'ORDER BY birthdate DESC LIMIT 10');
}
</pre>
<p>The <tt class="docutils literal">Where</tt> class has two very handy methods: <tt class="docutils literal">andWhere</tt> and <tt class="docutils literal">orWhere</tt> which can take string or another <tt class="docutils literal">Where</tt> instance as argument. All methods return a <tt class="docutils literal">Where</tt> instance so it is possible to chain the calls. The example above can be rewritten this way:</p>
<pre class="literal-block">
public function getYoungerThan(DateTime $date, $needle)
{
  $where = Pomm\Query\Where::create(&quot;birthdate &gt; $*&quot;, array($date))
      -&gt;andWhere('first_name ILIKE $*', array(sprintf('%%%s%%', $needle)))

  return $this-&gt;findWhere($where, null, 'ORDER BY birthdate DESC LIMIT 10');
}
</pre>
<p>Because the <tt class="docutils literal">WHERE something IN <span class="pre">(...)</span></tt> clause needs to declare as many '$*' as given parameters, it has its own constructor:</p>
<pre class="literal-block">
// WHERE (station_id, line_no) IN ((1, 1), (1, 3), ... );

$this-&gt;findWhere(Pomm\Query\Where::createWhereIn(&quot;(station_id, line_no)&quot;, array(array(1, 1), array(1, 3)))
</pre>
<p>The <tt class="docutils literal">Where</tt> instances can be combined together with respect of the logical precedence:</p>
<pre class="literal-block">
$where1 = new Pomm\Query\Where('pika = $*', array('chu'));
$where2 = new Pomm\Query\Where('age &lt; $*', array(18));

$where1-&gt;orWhere($where2);
$where1-&gt;andWhere(Pomm\Query\Where::createWhereIn('other_id', array(1,2,3,5,7,11)));

echo $where1; // (pika = $* OR age &lt; $*) AND other_id IN ($*,$*,$*,$*,$*,$*)
</pre>
</div>
<div class="section" id="fields-methods">
<h3><a class="toc-backref" href="#id46">Fields methods</a></h3>
<p>A very useful property of SQL sets is that they are extendibles. It possible to add a new field or remove an existing one in a SELECT very easily. All the generic finders described above use the following methods to know what fields to retrieve from queries:</p>
<ul class="simple">
<li><tt class="docutils literal">getFields</tt></li>
<li><tt class="docutils literal"><span class="pre">getSelectFields($alias)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">getGroupByFields($alias)</span></tt></li>
</ul>
<p><strong>getFields($table_alias)</strong> is the parent of all the fields getters. It returns an array of the form <tt class="docutils literal">field_alias =&gt; <span class="pre">$table_alias.$field_name</span></tt>. Table alias is optional and can be omitted. All other fields getters use <tt class="docutils literal">getFields</tt> internally and this is the method to be used to create fields getters.</p>
<p><strong>getSelectFields($alias)</strong> is used by all the finders by also by the update, delete and insert methods in their <tt class="docutils literal">RETURNING</tt> clause. Overloading this one will change their behavior also.</p>
<p><strong>getGroupByFields($alias)</strong> is to be used in <tt class="docutils literal">GROUP BY</tt> clauses. Note that Postgresql &gt;= 9.1 does not enforce grouping all the fields present in the select as soon as they are grouped by primary key. So this method is to be used only when using Postgres 9.0.</p>
<p>The following example show how to modify the fields for a table containing user informations:</p>
<pre class="literal-block">
public function getSelectFields($alias = null)
{
    $fields = parent::getSelectFields($alias);
    $alias = is_null($alias) ? $alias.&quot;.&quot; : '';

    // We do never retrieve password informations
    unset($fields['password']);

    // Add gravatar id in the select
    $fields['gravatar'] = sprintf(&quot;md5(%s.email_address)&quot;, $alias);

    return $fields;
}

// elsewhere in the code
$employee = $employee_map-&gt;findByPk(array('email' =&gt; 'pika.chu&#64;gmail.com'));
$employee-&gt;has('password'); // false
$employee-&gt;get('gravatar'); // 6c3e76d8b31679442f089cd3e7edb48a
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The example above shows the use of a Postgresql's function to calculate the gravatar field. It is obviously possible to use all Postgresql operators and functions in the fields, which makes this feature a very powerful ally.</p>
</div>
</div>
<div class="section" id="building-custom-queries">
<h3><a class="toc-backref" href="#id47">Building custom queries</a></h3>
<p>Even if generic finders may fulfill 90% of developers needs, it is possible to define your own finders using SQL. The generic structures of the SQL with Pomm follow the principle described below:</p>
<pre class="literal-block">
   SELECT
     :table_fields
   FROM
     :table_name
   WHERE
     :conditions

* The first string is provided by one fields getter method (see `Fields methods`_ above).
* The second string is the set's source, most of the time a table name. This is provided by the ``getTableName($alias)`` method.
* The last string is the where clause. If a ``Where`` instance is provided, it is as easy as casting it to String.
</pre>
</div>
<div class="section" id="fields-formatters">
<h3><a class="toc-backref" href="#id48">Fields formatters</a></h3>
<p>Field getters return an array of fields. This array has to be processed to get a string of fields usable in a SQL query. This is the role of the fields formatters methods:</p>
<blockquote>
<ul class="simple">
<li>formatFields('method_name', 'table_alias') returns a string with a comma separated list of fields.</li>
<li>formatFieldsWithAlias('method_name', 'table_alias') same as above but with fields aliases.</li>
</ul>
</blockquote>
<p>These methods call the fields getter given as <em>method_name</em> and return the formatted list of fields:</p>
<pre class="literal-block">
$where = new \Pomm\Query\Where::create(&quot;age &lt; $*&quot;, array(18))
    -&gt;andWhere('main_teacher_id = $*', array(1));

$sql = &quot;SELECT :table_fields FROM :table_name WHERE :conditions&quot;;

$sql = strtr($sql, array(
    ':table_fields' =&gt; $this-&gt;formatFieldsWithAlias('getSelectFields', 'my_table'),
    ':table_name'   =&gt; $this-&gt;getTableName('my_table'),
    ':conditions'   =&gt; (string) $where
    ));

return $this-&gt;query-&gt;($sql, $where-&gt;getValues());
</pre>
<p>This will perform the following query:</p>
<pre class="literal-block">
SELECT
  &quot;my_table.field1&quot; AS &quot;field1&quot;,
  &quot;my_table.field2&quot; AS &quot;field2&quot;,
  ...
FROM
  a_table my_table
WHERE
  age &lt; $* AND main_teacher_id = $*
</pre>
<p>with parameter 1 = 18 and parameter 2 = 1.</p>
</div>
<div class="section" id="complex-queries">
<h3><a class="toc-backref" href="#id49">Complex queries</a></h3>
<p>The example above is roughly what is coded in <tt class="docutils literal">findWhere</tt>.In real life, it is very likely one needs to join several database tables and their fields. Pomm makes it easy to get other map files from within any other map class.</p>
<pre class="literal-block">
// MyDatabase\Blog\PostMap Class
public function getBlogPostsWithCommentCount(Pomm\Query\Where $where)
{
  $comment_map = $this-&gt;connection-&gt;getMapFor('\MyDatabase\Blog\Comment');

  $sql = &lt;&lt;&lt;_
  SELECT
    :post_fields,
    COUNT(c.id) as &quot;comment_count&quot;
  FROM
    :post_table p
      LEFT JOIN :comment_table c ON
          p.id = c.p_id
  WHERE
      :conditions
  GROUP BY
      :post_groupby_fields
  _;

  $sql = strtr($sql, array(
      ':post_fields'        =&gt; $this-&gt;formatFieldsWithAlias('getSelectFields', 'p'),
      ':post_table'         =&gt; $this-&gt;getTableName(),
      ':comment_table'      =&gt; $comment_map-&gt;getTableName(),
      ':conditions'         =&gt; (string) $where,
      'post_groupby_fields' =&gt; $this-&gt;formatFields('getGroupByFields', 'p')
      ));

  return $this-&gt;query($sql, $where-&gt;getValues());
}
</pre>
<p>The <tt class="docutils literal">query()</tt> method is available for custom queries. It takes 2 parameters, the SQL statement and an optional array of values to be escaped. Keep in mind, the number of values must match the '$*' Occurrences in the query.</p>
<p>Whatever the data fetched, Pomm will hydrate objects according to what is in structure definition of map class. <strong>Entities do not know about their structure</strong> they just contain data and methods. The entity instances returned here will have this extra field &quot;comment_count&quot; exactly as it would be a normal field. Of course, when updating, this field will be ignored and will not cause an error.</p>
</div>
<div class="section" id="virtual-fields">
<h3><a class="toc-backref" href="#id50">Virtual fields</a></h3>
<p>Adding new fields in the SELECT trough the fields getter methods do not make them mapped to any known type hence not converted with the converter system. It is possible to assign these now &quot;virtual fields&quot; a converter.</p>
<pre class="literal-block">
// Map a field added in getSelectFields to then Interval converter.
$this-&gt;addVirtualField('created_since', 'Interval');
</pre>
<p>This feature is interesting since SQL queries can fetch objects directly:</p>
<pre class="literal-block">
SELECT author, array_agg(post) AS posts FROM author JOIN post ON post.author_id = author.id GROUP BY author...;

+----+-------------------+-------------------------------------
| id |       name        |                  posts
+----+-------------------+-------------------------------------
|  1 | john doe          | &quot;{('post 1', 1, 'some content'),(
+----+-------------------+-------------------------------------
|  2 | Edgar             | &quot;{('other post', 2, 'Other content'),
+----+-------------------+-------------------------------------
</pre>
<p>Using an entity converter will make an entity instance fetched directly from the database. The example below creates a relationship between the author and the post tables getting all the posts from one author in an array of Post instances:</p>
<pre class="literal-block">
// YourDb\SchemaName\AuthorMap

public function getOneWithPosts($author_name)
{
    $remote_map = $this-&gt;connection-&gt;getMapFor('YourDb\SchemaName\Post');

    $sql = &lt;&lt;&lt;_
    SELECT
      :author_fields,
      array_agg(post) AS posts
    FROM
      :author_table
        LEFT JOIN :post_table ON
            author.id = post.author_id
    WHERE
        author.name = $*
    GROUP BY
      :author_groupby_fields
    ;

    $sql = strtr($sql, array(
        ':author_fields' =&gt; $this-&gt;formatFieldsWithAlias('getSelectFields', 'author'),
        ':author_table' =&gt; $this-&gt;getTableName('author'),
        ':post_table' =&gt; $remote_map-&gt;getTableName('post'),
        ':author_groupby_fields' =&gt; $this-&gt;getGroupByFields('author')
        ));

    $this-&gt;addVirtualField('posts', 'schema_name.post[]');

    return $this-&gt;query($sql, array($author_name));
}
</pre>
<p>In this example we assume the <tt class="docutils literal">schema_name.post</tt> type has already been associated with the <tt class="docutils literal">PgEntity</tt> converter with its map class (see <a class="reference internal" href="#entity-converter">Entity converter</a>). The fetched <tt class="docutils literal">Author</tt> instances will have an extra attribute <tt class="docutils literal">posts</tt> containing an array of <tt class="docutils literal">Post</tt> instances (see <a class="reference internal" href="#arrays">Arrays</a>). This is a very powerful feature because any entity's related objects can be fetched from the database and hydrated on the fly.</p>
</div>
</div>
<div class="section" id="collections">
<h2><a class="toc-backref" href="#id51">Collections</a></h2>
<div class="section" id="fetching-results">
<h3><a class="toc-backref" href="#id52">Fetching results</a></h3>
<p>The <tt class="docutils literal">query()</tt> method return a <tt class="docutils literal">Collection</tt> instance that holds the PDOStatement with the results. The <tt class="docutils literal">Collection</tt> class implements the <tt class="docutils literal">Countable</tt> and <tt class="docutils literal">Iterator</tt> interfaces so they can be traversed using a <tt class="docutils literal">foreach</tt> PHP statement to retrieve the results:</p>
<pre class="literal-block">
printf(&quot;Your search returned '%d' results.&quot;, $collection-&gt;count());

foreach($collection as $blog_post)
{
  printf(&quot;Blog post '%s' posted on '%s' by '%s'.&quot;,
      $blog_post['title'],
      $blog_post['created_at']-&gt;format('Y-m-d'),
      $blog_post['author']
      );
}
</pre>
<p>Any particular result in a collection can be reached knowing the result's index. It is possible using the <tt class="docutils literal">has()</tt> and <tt class="docutils literal">get()</tt> methods:</p>
<pre class="literal-block">
# Get an object from the collection at a given index
# or create a new one if index does not exist
$object = $collection-&gt;has($index) ?  $collection-&gt;get($index) : new Object();
</pre>
<dl class="docutils">
<dt>Collections have other handful methods like:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal">isFirst()</tt></li>
<li><tt class="docutils literal">isLast()</tt></li>
<li><tt class="docutils literal">isEmpty()</tt></li>
<li><tt class="docutils literal">isOdd()</tt></li>
<li><tt class="docutils literal">isEven()</tt></li>
<li><tt class="docutils literal">getOddEven()</tt></li>
<li><tt class="docutils literal">extract()</tt></li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="collection-filters">
<h3><a class="toc-backref" href="#id53">Collection filters</a></h3>
<p>Pomm's <tt class="docutils literal">Collection</tt> class can register filters. Filters are just functions that are executed after values were fetched from the database and before the object is hydrated with them (pre hydration filters). These filters take the array of fetched values as parameter. They return an array with values which are then given to the next filter and so on. After all filters have been executed, the values are hydrated in entity instance related the map the collection comes from.</p>
<pre class="literal-block">
$collection = $this-&gt;query($sql, $values);

$collection-&gt;registerFilter(function($values) {
    $values['good_pika'] = $values['pika'] == 'chu' ? 'Good' : 'Try again';

    return $values;
    });
</pre>
<p>The code above register a filter that create an extra field in our result set. Every time a result is fetched, this anonymous function will be triggered and the resulting values will be hydrated in the entity.</p>
</div>
</div>
<div class="section" id="pagers">
<h2><a class="toc-backref" href="#id54">Pagers</a></h2>
<div class="section" id="pager-query-methods">
<h3><a class="toc-backref" href="#id55">Pager query methods</a></h3>
<p><tt class="docutils literal">BaseObjectMap</tt> instances provide 2 methods that will grant programmers with a <tt class="docutils literal">Pager</tt> class. <tt class="docutils literal">paginateQuery()</tt> and the handy <tt class="docutils literal">paginateFindWhere()</tt>. It adds the correct subset limitation at the end of queries. Of course, it assumes no LIMIT nor OFFSET sql clauses are already present in the given query.</p>
<p>The <tt class="docutils literal">paginateFindWhere()</tt> method acts pretty much like the <tt class="docutils literal">findWhere()</tt> method (see <a class="reference internal" href="#built-in-finders">Built-in finders</a>) which it uses internally. This means the condition can be either a string or a <tt class="docutils literal">Pomm\Query\Where</tt> instance (see <a class="reference internal" href="#and-or-the-where-class">AND, OR: The Where class</a>):</p>
<pre class="literal-block">
$pager = $student_map
  -&gt;paginateFindWhere('age &lt; $* OR gender = $*', array(19, 'F'), 'ORDER BY score ASC', 25, 4);
</pre>
<p>The example below ask Pomm to retrieve the fourth page of students that match some condition with 25 results per page.</p>
<p>The <tt class="docutils literal">paginateQuery()</tt> acts like the <tt class="docutils literal">query()</tt> method but it requires 2 SQL queries: the one that returns results and the one that counts the total number of rows that first query would return without paging.</p>
</div>
<div class="section" id="displaying-a-pager">
<h3><a class="toc-backref" href="#id56">Displaying a pager</a></h3>
<p><tt class="docutils literal">Pager</tt> instances come with methods to display basic page informations like page count, current page, first result row etc. Here is an example of how to display a page in a twig template:</p>
<pre class="literal-block">
&lt;ul&gt;
  {% for student in pager.getCollection() %}
    &lt;li&gt;{{ student }}&lt;/li&gt;
  {% endfor %}
&lt;/ul&gt;
{% if pager.getLastPage() &gt; 1 %}
&lt;div class=&quot;pager&quot;&gt;&lt;p&gt;
&lt;a href=&quot;{{ app.url_generator.generate('news') }}&quot;&gt;First&lt;/a&gt;
{% if pager.isPreviousPage() %}
&lt;a href=&quot;{{ app.url_generator.generate('news', {'page': pager.getPage - 1}) }}&quot;&gt;Previous&lt;/a&gt;
{% else %}
Previous
{% endif %}
News {{ pager.getResultMin() }} to {{ pager.getResultMax() }}
{% if pager.isNextPage() %}
&lt;a href=&quot;{{ app.url_generator.generate('news', {'page': pager.getPage + 1} ) }}&quot;&gt;Next&lt;/a&gt;
{% else %}
Next
{% endif %}
&lt;a href=&quot;{{ app.url_generator.generate('news', {'page': pager.getLastPage} ) }}&quot;&gt;Last&lt;/a&gt;
&lt;/p&gt;&lt;/div&gt;
{% endif %}
</pre>
</div>
</div>
</div>
<div class="section" id="entities">
<h1><a class="toc-backref" href="#id57">Entities</a></h1>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id58">Overview</a></h2>
<div class="section" id="what-is-an-entity-class">
<h3><a class="toc-backref" href="#id59">What is an Entity class ?</a></h3>
<p>Entities are what programmers use in the end of the process. They are an object oriented implementation of the data retrieved from the database. Most of the time, these PHP classes are automatically generated by the introspection tool (see <a class="reference internal" href="#createbasemaptool">CreateBaseMapTool</a>) but you can write your own classes by hand. They just have to extends the <tt class="docutils literal">Pomm\Object\BaseObject</tt> class to know about status (see <a class="reference internal" href="#life-cycle">Life cycle</a>). Important things to know about entities are <strong>they are schema less</strong> and <strong>they are data source agnostic</strong>.</p>
<p>By default, entities lie in the same directory than their map classes and de facto share the same namespace but this is only a convention.</p>
<pre class="literal-block">
&lt;?php

namespace Database\Schema;

use Pomm\Object\BaseObject;
use Pomm\Exception\Exception;

class MyEntity extends BaseObject
{
}
</pre>
</div>
<div class="section" id="data-source-agnostic">
<h3><a class="toc-backref" href="#id60">Data source agnostic</a></h3>
<p>Entities do not know anything about database in general. This means they do not know how to save, retrieve or update themselves (see <a class="reference internal" href="#map-classes">Map classes</a> for that). <tt class="docutils literal">BaseObject</tt> children can be used to store data from web services, NoSQL database etc. They use the <tt class="docutils literal">hydrate()</tt> method to get data and accessors to read / write data from them (see <a class="reference internal" href="#living-with-entities">Living with entities</a> below).</p>
</div>
<div class="section" id="schema-less-entities">
<h3><a class="toc-backref" href="#id61">Schema less entities</a></h3>
<p>Entities do not know anything about the structure of the tables, views etc. They are just flexible typed containers for data. They use PHP magic methods to simulate getters and setters on data they own (see <a class="reference internal" href="#living-with-entities">Living with entities</a> below). This is very powerful because entities can be accessed like arrays and still benefits from method overloads.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Entities do not know anything about their primary key either.</p>
</div>
</div>
</div>
<div class="section" id="living-with-entities">
<h2><a class="toc-backref" href="#id62">Living with entities</a></h2>
<div class="section" id="creator">
<h3><a class="toc-backref" href="#id63">Creator</a></h3>
<p>There are several ways to create entities.</p>
<pre class="literal-block">
$entity = new Database\Schema\MyEntity();
</pre>
<p>It is possible to directly specify values to the constructor:</p>
<pre class="literal-block">
$entity = new Database\Schema\MyEntity(array('value1' =&gt; $value1, ... ));
</pre>
<p>Entity's according map class also proposes methods to create entities (see <a class="reference internal" href="#map-classes">Map classes</a>).</p>
</div>
<div class="section" id="accessors-and-mutators">
<h3><a class="toc-backref" href="#id64">Accessors and mutators</a></h3>
<p>The abstract parent <tt class="docutils literal">BaseObject</tt> uses magic getters and setters to dynamically build the according methods. Internally, all values are stored in an array. The methods <tt class="docutils literal">set()</tt> and <tt class="docutils literal">get()</tt> are the interface to this array:</p>
<pre class="literal-block">
$entity = new Database\Schema\MyEntity();
$entity-&gt;has('pika'); // false
$entity-&gt;set('pika', 'chu');
$entity-&gt;has('pika'); // true
$entity-&gt;get('pika'); // chu
$entity-&gt;clear('pika');
$entity-&gt;has('pika'); // false
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p><tt class="docutils literal">get()</tt> can take an array with multiple attributes:</p>
<pre class="literal-block">
$entity-&gt;set('pika', 'chu');
$entity-&gt;set('plop', true);
</pre>
<p class="last">$entity-&gt;get(array('pika', 'plop')); // returns array('pika' =&gt; 'chu', 'plop' =&gt; true);</p>
</div>
<p><tt class="docutils literal">get()</tt>, <tt class="docutils literal">clear()</tt> and <tt class="docutils literal">set()</tt> are <strong>generic accessors</strong>. They are used internally and cannot be overloaded. Use <strong>virtual accessors</strong> instead:</p>
<pre class="literal-block">
$entity = new Database\Schema\MyEntity(array('pika' =&gt; 'chu'));
$entity-&gt;getPika();      // chu
</pre>
<p>They are called virtual because they do not exist by default but <tt class="docutils literal">BaseObject</tt> implements the <tt class="docutils literal">__call()</tt> method to trap accessors calls using the <tt class="docutils literal">get()</tt> and <tt class="docutils literal">set()</tt> generic methods. Of course, they can be overloaded:</p>
<pre class="literal-block">
// in the Entity class
public function getPika()
{
  return strtoupper($this-&gt;get('pika'));
}

// elsewhere
$entity = new Database\Schema\MyEntity(array('pika' =&gt; 'chu'));
$entity-&gt;getPika();     // CHU
</pre>
<p>Since the methods <tt class="docutils literal">set()</tt> and <tt class="docutils literal">get()</tt> cannot be overloaded, they will always return raw values stored in the entity container. They are used to bypass overloading methods.</p>
</div>
<div class="section" id="interfaces-and-overloads">
<h3><a class="toc-backref" href="#id65">Interfaces and overloads</a></h3>
<p>Entities implement PHP's <tt class="docutils literal">ArrayAccess</tt> interface to use the accessors if any. This means programmers can have easy access to entity's data in templates without bypassing accessors:</p>
<pre class="literal-block">
// in the Entity class
public function getPika()
{
  return strtoupper($this-&gt;get('pika'));
}

// elsewhere
$entity-&gt;setPika('chu');
$entity-&gt;getPika();     // CHU
$entity['pika'];        // CHU
$entity-&gt;pika;          // CHU

$entity-&gt;get('pika');   // chu
</pre>
<p>This also applies to <tt class="docutils literal">set()</tt> and <tt class="docutils literal">clear()</tt> methods.</p>
<p>This is particularly useful when exposing entities data in interfaced or template system.</p>
</div>
<div class="section" id="extending-entities">
<h3><a class="toc-backref" href="#id66">Extending entities</a></h3>
<blockquote>
<p>It is possible to extend entities providing new accessors. If by example there is an entity with a weight in grams and you would like to have a getter that returns it in ounces:</p>
<pre class="literal-block">
public function getWeightInOunce()
{
  return round($this-&gt;getWeight() * 0.0352739619, 2);
}
</pre>
</blockquote>
<p>In templates, it is possible to directly benefit from this getter while using the entity as an array:</p>
<pre class="literal-block">
// in PHP
&lt;?php echo $thing['weight_in_ounce'] ?&gt;

// with Twig
{{ thing.weight_in_ounce }}
</pre>
</div>
</div>
<div class="section" id="entities-and-database">
<h2><a class="toc-backref" href="#id67">Entities and database</a></h2>
<div class="section" id="import-and-export">
<h3><a class="toc-backref" href="#id68">Import and export</a></h3>
<p><tt class="docutils literal">Pomm</tt> proposes several mechanisms to import or export entities data as array. The <tt class="docutils literal">hydrate()</tt> method takes an array and merge it with the entity's internal values. Be aware PHP associative arrays keys are case sensitive while Postgresql's field names are not. If some sort of conversion is required, the <tt class="docutils literal">convert()</tt> method will help. You can overload the <tt class="docutils literal">convert()</tt> method to create a more specific conversion (if you use web services data provider by example) but you cannot overload the <tt class="docutils literal">hydrate()</tt> method.</p>
<p><tt class="docutils literal">export</tt> will dump entity's internal data without regard to getters.</p>
</div>
<div class="section" id="life-cycle">
<h3><a class="toc-backref" href="#id69">Life cycle</a></h3>
<p>Entities also propose mechanisms to check what state are their data compared to the data source. There are 2 states which present 4 possible combinations:</p>
<dl class="docutils">
<dt><strong>EXIST</strong></dt>
<dd>The instance exists in the database.</dd>
<dt><strong>MODIFIED</strong></dt>
<dd>This instance has been modified with mutators since hydration.</dd>
</dl>
<p>So, of course, an entity can be in both states EXIST and MODIFIED or NONE of them. The <tt class="docutils literal">BaseObject</tt> class grants programmers with several methods to check this internal state: <tt class="docutils literal">isNew()</tt>, <tt class="docutils literal">isModified()</tt> or you can directly access the <tt class="docutils literal">status</tt> attribute from within class definition:</p>
<pre class="literal-block">
$entity = $map-&gt;createObject();
$entity-&gt;isNew();           // true
$entity-&gt;isModified();      // false
$entity-&gt;setPika('chu');
$entity-&gt;isNew();           // true
$entity-&gt;isModified();      // true
</pre>
</div>
</div>
</div>
<div class="section" id="tools">
<h1><a class="toc-backref" href="#id70">Tools</a></h1>
<div class="section" id="map-generation-tools">
<h2><a class="toc-backref" href="#id71">Map generation tools</a></h2>
<p>Pomm comes with handy tools to generate map classes that reflect what is in your database.</p>
<div class="section" id="database-inspector">
<h3><a class="toc-backref" href="#id72">Database Inspector</a></h3>
<p>The database inspector class proposes methods to scavenge structure informations in the database. It is used by the Map generators and you can use it in your own scripts.</p>
</div>
<div class="section" id="createbasemaptool">
<h3><a class="toc-backref" href="#id73">CreateBaseMapTool</a></h3>
<p>This class is the main generator class.</p>
<blockquote>
<ul class="simple">
<li>It inspects the database for the given table / view.</li>
<li>It creates the directory structure for your namespaces.</li>
<li>It generates the BaseMap file from the structure detected in the database.</li>
<li>It generates according empty entity and map files if they do not exist.</li>
</ul>
</blockquote>
<p>This class accepts the following parameters:</p>
<blockquote>
<ul class="simple">
<li>&quot;database&quot; a PommConnectionDatabase instance (mandatory).</li>
<li>&quot;table&quot; or &quot;oid&quot; (mandatory)</li>
<li>&quot;prefix_dir&quot; Where to generate the tree on the disk (mandatory).</li>
<li>&quot;schema&quot; (default to 'public').</li>
<li>&quot;parent_namespace&quot; When inheritance is found, override the default namespace for parent.</li>
<li>&quot;namespace&quot; (default to '%dbname%%schema%') The namespace placeholder.</li>
<li>&quot;extends&quot; (default to PommObjectBaseObjectMap).</li>
<li>&quot;class_name&quot; The corresponding entity class. (default camel cased table's name).</li>
</ul>
</blockquote>
<p><strong>table</strong> or <strong>oid</strong></p>
<p>If you give both, the oid has precedence over the name.</p>
<p><strong>prefix_dir</strong></p>
<p>This is the root directory from which the directory tree will be built. The directory by default respects the PSR-0 standard to allow autoloading according to namespaces but you can change it.</p>
<p><strong>schema</strong>
The database schema name where the table or view is located.</p>
<p><strong>namespace</strong>
The namespace parameter is a placeholder. There are 2 values that can be substituted with their camel cased name: <em>%schema%</em> and <em>%dbname%</em>. By default, the namespace follows the directory structure.</p>
<p><strong>parent_namespace</strong>
When database table inheritance is found, this parameter override the default namespace for the parent map class. Otherwise the parent is assumed to be in the default namespace.</p>
<p><strong>extends</strong>
By default, the generated base class extends <tt class="docutils literal">\Pomm\Object\BaseObjectMap</tt> but you might want to set another class. The final parent of the map class must be BaseObjectMap in the end.</p>
<p><strong>class_name</strong>
In case of generating map class for a view, it may be a good idea to tell Pomm that entities fetched by this map are something else than it thinks. This makes possible to have different views of the same table fetching the same entities from them.</p>
</div>
<div class="section" id="scanschematool">
<h3><a class="toc-backref" href="#id74">ScanSchemaTool</a></h3>
<p>The schema scanning tool takes a schema name as parameter and then launches CreateBaseMapTool for each table / view it finds in it. The expected parameters are the following:</p>
<blockquote>
<ul class="simple">
<li>&quot;database&quot; a PommConnectionDatabase instance (mandatory).</li>
<li>&quot;prefix_dir&quot; Where to generate the tree on the disk (mandatory).</li>
<li>&quot;schema&quot; (default to 'public').</li>
<li>&quot;namespace&quot; (default to '%dbname%%schema%') The namespace placeholder.</li>
<li>&quot;extends&quot; (default to PommObjectBaseObjectMap).</li>
<li>&quot;parent_namespace&quot; When inheritance is found, override the default namespace for parent.</li>
<li>&quot;exclude&quot; (optional) an array of tables/views not to generate files from.</li>
</ul>
</blockquote>
<p>Most of these parameters are sent to the <tt class="docutils literal">CreateBaseMapTool</tt> as is. The only different parameter is</p>
<p><strong>exclude</strong>
An array of tables/views to ignore.</p>
<p>Here is a sample of code to generate map classes from all the tables/views in a database schema:</p>
<pre class="literal-block">
&lt;?php

require __DIR__.'/vendor/pomm/test/autoload.php';

$database = new Pomm\Connection\Database(array(
        'dsn'  =&gt; 'pgsql://nss_user:nss_password&#64;localhost/nss_db',
        'name' =&gt; 'my_db'
        ));

$scan = new Pomm\Tools\ScanSchemaTool(array(
    'prefix_dir'=&gt; __DIR__,
    'schema' =&gt; 'transfo',
    'database' =&gt; $database
));

$scan-&gt;execute();
</pre>
<p>This will parse the Postgresql's schema named <em>transfo</em> to scan it for tables and views. Then it will generate automatically the <em>BaseMap</em> files with the class structure and if map files or entity files do not exist, will create them. By default, with the code above, the following tree structure will be created from the directory this code is invoked:</p>
<pre class="literal-block">
/prefix/dir/MyDb
└── Transfo
 &nbsp;&nbsp; ├── Base
 &nbsp;&nbsp; │&nbsp;&nbsp; └── TransformerMap.php
 &nbsp;&nbsp; ├── TransformerMap.php
 &nbsp;&nbsp; └── Transformer.php
</pre>
</div>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
Generated on: 2013-11-13.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
