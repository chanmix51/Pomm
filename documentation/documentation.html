<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0039) -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="generator" content="Docutils 0.7: http://docutils.sourceforge.net/">
<title>Pomm Documentation</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 6253 2010-03-02 00:24:53Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: left }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="pomm-documentation">
<h1 class="title">Pomm Documentation</h1>

<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#overview" id="id4">Overview</a></li>
<li><a class="reference internal" href="#databases-and-converters" id="id5">Databases and converters</a><ul>
<li><a class="reference internal" href="#service-the-database-provider" id="id6">Service: the database provider</a><ul>
<li><a class="reference internal" href="#database-class-and-isolation-level" id="id7">Database class and isolation level</a></li>
<li><a class="reference internal" href="#dsn" id="id8">DSN</a></li>
</ul>
</li>
<li><a class="reference internal" href="#converters" id="id9">Converters</a><ul>
<li><a class="reference internal" href="#built-in-converters" id="id10">Built-in converters</a></li>
<li><a class="reference internal" href="#registering-converters" id="id11">Registering converters</a></li>
</ul>
</li>
<li><a class="reference internal" href="#converters-and-types" id="id12">Converters and types</a><ul>
<li><a class="reference internal" href="#domains" id="id13">Domains</a></li>
<li><a class="reference internal" href="#custom-types" id="id14">Custom types</a></li>
<li><a class="reference internal" href="#writing-your-own-converters" id="id15">Writing your own converters</a></li>
<li><a class="reference internal" href="#entity-converter" id="id16">Entity converter</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#entities" id="id17">Entities</a><ul>
<li><a class="reference internal" href="#id1" id="id18">Overview</a><ul>
<li><a class="reference internal" href="#what-is-an-entity-class" id="id19">What is an Entity class ?</a></li>
<li><a class="reference internal" href="#data-source-agnostic" id="id20">Data source agnostic</a></li>
<li><a class="reference internal" href="#schemaless-entities" id="id21">Schemaless entities</a></li>
</ul>
</li>
<li><a class="reference internal" href="#living-with-entities" id="id22">Living with entities</a><ul>
<li><a class="reference internal" href="#creator" id="id23">Creator</a></li>
<li><a class="reference internal" href="#accessors-and-mutators" id="id24">Accessors and mutators</a></li>
<li><a class="reference internal" href="#interfaces-and-overloads" id="id25">Interfaces and overloads</a></li>
<li><a class="reference internal" href="#extending-entities" id="id26">Extending entities</a></li>
</ul>
</li>
<li><a class="reference internal" href="#entities-and-database" id="id27">Entities and database</a><ul>
<li><a class="reference internal" href="#hydrate-and-convert" id="id28">Hydrate and convert</a></li>
<li><a class="reference internal" href="#life-cycle" id="id29">Life cycle</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#map-classes" id="id30">Map classes</a><ul>
<li><a class="reference internal" href="#id2" id="id31">Overview</a></li>
<li><a class="reference internal" href="#structure" id="id32">Structure</a><ul>
<li><a class="reference internal" href="#introspected-tables" id="id33">Introspected tables</a></li>
<li><a class="reference internal" href="#arrays" id="id34">Arrays</a></li>
<li><a class="reference internal" href="#temporary-tables" id="id35">Temporary tables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#querying-the-database" id="id36">Querying the database</a><ul>
<li><a class="reference internal" href="#create-update-drop" id="id37">Create, update, drop</a></li>
<li><a class="reference internal" href="#built-in-finders" id="id38">Built-in finders</a></li>
<li><a class="reference internal" href="#findwhere" id="id39">findWhere</a></li>
<li><a class="reference internal" href="#and-or-the-where-class" id="id40">AND OR: The Where class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#custom-queries" id="id41">Custom queries</a><ul>
<li><a class="reference internal" href="#fields-methods" id="id42">fields methods</a></li>
<li><a class="reference internal" href="#virtual-fields" id="id43">Virtual fields</a></li>
</ul>
</li>
<li><a class="reference internal" href="#collections" id="id44">Collections</a><ul>
<li><a class="reference internal" href="#fetching-results" id="id45">fetching results</a></li>
<li><a class="reference internal" href="#collection-filters" id="id46">Collection filters</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pagers" id="id47">Pagers</a><ul>
<li><a class="reference internal" href="#pager-query-methods" id="id48">Pager query methods</a></li>
<li><a class="reference internal" href="#displaying-a-pager" id="id49">Displaying a pager</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#connections" id="id50">Connections</a><ul>
<li><a class="reference internal" href="#id3" id="id51">Overview</a><ul>
<li><a class="reference internal" href="#map-classes-provider" id="id52">Map classes provider</a></li>
<li><a class="reference internal" href="#identity-mappers" id="id53">Identity mappers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#transactions" id="id54">Transactions</a><ul>
<li><a class="reference internal" href="#standard-transactions" id="id55">Standard transactions</a></li>
<li><a class="reference internal" href="#partial-transactions-and-savepoints" id="id56">Partial transactions and savepoints</a></li>
</ul>
</li>
<li><a class="reference internal" href="#query-filter-chain" id="id57">Query filter chain</a><ul>
<li><a class="reference internal" href="#loggerfilterchain" id="id58">LoggerFilterChain</a></li>
<li><a class="reference internal" href="#writing-a-filter" id="id59">Writing a Filter</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#tools" id="id60">Tools</a><ul>
<li><a class="reference internal" href="#php-tools" id="id61">PHP tools</a></li>
<li><a class="reference internal" href="#database-tools" id="id62">Database tools</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="overview">
<h1><a class="toc-backref" href="#id4">Overview</a></h1>
<p>Pomm is a fast, lightweight, efficient model manager for Postgresql written in PHP. It can be seen as an enhanced object hydrator above PDO with the following features:</p>
<blockquote>
<ul class="simple">
<li>Database Inspector to build automatically your PHP model files. Table inheritance from Pg will make your model class to inherit from each other.</li>
<li>Namespaces are used to ovoid collision between objects located in different Pg schemas.</li>
<li>Types are converted on the fly. 't' and 'f' Pg booleans are converted into PHP booleans, so are binary, arrays, geometric and your own data types.</li>
<li>Queries results are fetched on demand to keep minimal memory fingerprint.</li>
<li>It is possible to register anonymous PHP functions to filter fetched results prior to hydration.</li>
<li>Model objects are extensible, simply add fields in your SELECT statements.</li>
<li>Pomm uses an identity mapper, fetching twice the same rows will return same instances.</li>
<li>You can register code to be executed before and/or after each query (logs, filters, event systems ...)</li>
</ul>
</blockquote>
</div>
<div class="section" id="databases-and-converters">
<h1><a class="toc-backref" href="#id5">Databases and converters</a></h1>
<div class="section" id="service-the-database-provider">
<h2><a class="toc-backref" href="#id6">Service: the database provider</a></h2>
<div class="section" id="database-class-and-isolation-level">
<h3><a class="toc-backref" href="#id7">Database class and isolation level</a></h3>
<p>The <tt class="docutils literal">Service</tt> class just stores your <tt class="docutils literal">Database</tt> instances and provides convenient methods to create connections from them. There are several ways to declare databases to the service class. Either you use the constructor passing an array "name" =&gt; "connection parameters" or you can use the <tt class="docutils literal">setDatabase()</tt> method of the service class.:</p>
<pre class="literal-block"># The two examples below are equivalent
# Using the constructor
$service = new Pomm\Service(array(
  'db_one' =&gt; array(
    'dsn' =&gt; 'pgsql://user:pass@host:port/db_a'
  ),
  'db_two' =&gt; array(
    'dsn'   =&gt; 'pgsql://otheruser:hispass@!/path/to/socket/directory!/db_b',
    'class' =&gt; 'App\MyDb',
    'identity_mapper' =&gt; 'App\MyIdentityMapper',
    'name'  =&gt; 'my_db'
  )
  ));

# Using the setDatabase method
$service = new Pomm\Service();
$service-&gt;setDatabase('db_one', new Pomm\Connection\Database(array(
  'dsn' =&gt; 'pgsql://user:pass@host:port/db_a'
)));
$service-&gt;setDatabase('db_two', new App\MyDb(array(
  'dsn' =&gt; 'pgsql://otheruser:hispass@!/path/to/socket/directory!/db_b',
  'identity_mapper' =&gt; 'App\MyIdentityMapper',
  'name'  =&gt; 'my_db'
)));
</pre>
<dl class="docutils">
<dt>The <em>setDatabase</em> method is used internally by the constructor. The parameters may be any of the following:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal">dsn</tt> (mandatory): a URL like string to connect the database. It is in the form <tt class="docutils literal"><span class="pre">pgsql://user:password@host:port/database_name</span></tt></li>
<li><tt class="docutils literal">class</tt>: The <em>Database</em> class to instantiate as a database. This class must extend <tt class="docutils literal">Pomm\Database</tt> as we will see below.</li>
<li><tt class="docutils literal">isolation</tt>: transaction isolation level. (default is <tt class="docutils literal">ISOLATION_READ_COMMITTED</tt>, see <a class="reference internal" href="#standard-transactions">Standard transactions</a>)</li>
<li><tt class="docutils literal">name</tt>: the database alias name. If none is provided, the database real name is substitued. This option is notably used for namespacing map classes during database introspection (see <a class="reference internal" href="#php-tools">PHP tools</a> and <a class="reference internal" href="#introspected-tables">Introspected tables</a>).</li>
</ul>
</dd>
</dl>
<p>Once registered, you can retrieve the databases with their name by calling the <em>getDatabase</em> method passing the name as argument. If no name is given, the first declared <em>Database</em> will be returned.</p>
</div>
<div class="section" id="dsn">
<h3><a class="toc-backref" href="#id8">DSN</a></h3>
<p>The <strong>dsn</strong> parameter format is important because it interacts with the server's access policy.</p>
<blockquote>
<ul class="simple">
<li><strong>socket connection</strong></li>
<li><tt class="docutils literal"><span class="pre">pgsql://user/database</span></tt> Connect <em>user</em> to the db <em>database</em> without password through the Unix socket system. This is the DSN's shortest form.</li>
<li><tt class="docutils literal"><span class="pre">pgsql://user:pass/database</span></tt> The same but with password.</li>
<li><tt class="docutils literal"><span class="pre">pgsql://user:pass@!/path/to/socket!/database</span></tt> When the socket is not in the default directory, it is possible to specify it in the host part of the DSN. Note it is surrounded by '!' and there are NO ending /. Using the «!» as delimiter assumes there are no «!» in your socket's path. But you don't have «!» in your socket's path do you ?</li>
<li><tt class="docutils literal"><span class="pre">pgsql://user@!/path/to/socket!:port/database</span></tt> Postgresql's listening socket name are the same as TCP ports. If different than default socket, specify it in the port part.</li>
<li><strong>TCP connection</strong></li>
<li><tt class="docutils literal"><span class="pre">pgsql://user@host/database</span></tt> Connect <em>user</em> to the db <em>database</em> on host <em>host</em> using TCP/IP.</li>
<li><tt class="docutils literal"><span class="pre">pgsql://user:pass@host:port/database</span></tt> The same but with password and TCP port specified.</li>
</ul>
</blockquote>
<p>The <tt class="docutils literal">identity_mapper</tt> option gives you the opportunity to register an identity mapper. When connections are created, they will instantiate the given class. By default, the Smart IM is loaded. This can be overridden for specific connections (see the identity mapper section below).</p>
</div>
</div>
<div class="section" id="converters">
<h2><a class="toc-backref" href="#id9">Converters</a></h2>
<div class="section" id="built-in-converters">
<h3><a class="toc-backref" href="#id10">Built-in converters</a></h3>
<p>The <tt class="docutils literal">Database</tt> class brings access to mechanisms to create connections and also to register converters. A <tt class="docutils literal">Converter</tt> is a class that translates a data type from Postgresql to PHP and from PHP to Postgresql.</p>
<dl class="docutils">
<dt>By default, the following converters are registered, this means you can use them without configuring anything:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal">Boolean</tt>: convert postgresql booleans 't' and 'f' to/from PHP boolean values</li>
<li><tt class="docutils literal">Number</tt>: convert postgresql 'smallint', 'bigint', 'integer', 'decimal', 'numeric', 'real', 'double precision', 'serial', 'bigserial' types to numbers</li>
<li><tt class="docutils literal">String</tt>: convert postgresql 'varchar', 'uuid', 'xml' and 'text' into PHP string</li>
<li><tt class="docutils literal">Timestamp</tt>: convert postgresql 'timestamp', 'date', 'time' to PHP <tt class="docutils literal">DateTime</tt> instance.</li>
<li><tt class="docutils literal">Interval</tt>: convert postgresql's 'interval' type into PHP <tt class="docutils literal">SplInterval</tt> instance.</li>
<li><tt class="docutils literal">Binary</tt>: convert postgresql's 'bytea' type into PHP string.</li>
<li><tt class="docutils literal">Array</tt>: convert postgresql arrays from/to PHP arrays.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="registering-converters">
<h3><a class="toc-backref" href="#id11">Registering converters</a></h3>
<p>Other types are natively available in postgresql databases but are not loaded automatically by Pomm.</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal">Point</tt>: postgresql 'point' representation as <tt class="docutils literal">Pomm\Type\Point</tt> instance.</li>
<li><tt class="docutils literal">Segment</tt>: 'segment' representation as <tt class="docutils literal">Pomm\Type\Segment</tt>.</li>
<li><tt class="docutils literal">Circle</tt>: 'circle' representation as <tt class="docutils literal">Pomm\Type\Circle</tt>.</li>
</ul>
</blockquote>
<p>Postgresql contribs come with handy extra data type (like HStore, a key =&gt; value array and LTree a materialized path data type). If you use these types in your database you have to <strong>register the according converters</strong> from your database instance:</p>
<pre class="literal-block"># The HStore converter converts a postgresql HStore to a PHP associative
# array and the other way around.
# The following line registers the HStore converter to the default
# database.

$service
  -&gt;getDatabase()
  -&gt;registerConverter(
    'HStore',
     new Pomm\Converter\PgHStore(),
     array('hstore')
    );
</pre>
<dl class="docutils">
<dt>Arguments to instanciate a <tt class="docutils literal">Converter</tt> are the following:</dt>
<dd><ul class="first last simple">
<li>the first argument is the converter name. It is used in the map classes to link with fields (see <a class="reference internal" href="#map-classes">Map Classes</a> below).</li>
<li>the second argument is the instance of the <tt class="docutils literal">Converter</tt></li>
<li>the third argument is a type or a set of types for Pomm to link them with the given converter.</li>
</ul>
</dd>
</dl>
<p>If your database has a lot of custom types, it is a better idea to create your own <tt class="docutils literal">Database</tt> class.:</p>
<pre class="literal-block">class MyDatabase extends Pomm\Connection\Database
{
  protected function initialize()
  {
    parent::initialize();
    $this-&gt;registerConverter('HStore',
      new Pomm\Converter\Hstore(), array('hstore'));

    $this-&gt;registerConverter('Point',
      new Pomm\Converter\Pgpoint(), array('point'));

    $this-&gt;registerConverter('Circle',
      new Pomm\Converter\PgCircle(), array('circle'));
  }
}
</pre>
<p>This way, converters will be automatically registered at instantiation.</p>
</div>
</div>
<div class="section" id="converters-and-types">
<h2><a class="toc-backref" href="#id12">Converters and types</a></h2>
<div class="section" id="domains">
<h3><a class="toc-backref" href="#id13">Domains</a></h3>
<p>In case your database uses <tt class="docutils literal">DOMAIN</tt> types you can add them to an already registered converter. The <tt class="docutils literal">registerTypeForConverter()</tt> method stands for that.:</p>
<pre class="literal-block">$service-&gt;getDatabase('default')
  -&gt;registerTypeForConverter('email', 'String');
  ;
</pre>
<p>In the example above, the database contains a domain <tt class="docutils literal">email</tt> which is a subtype of <tt class="docutils literal">varchar</tt> so it is associated with the built-in converter <tt class="docutils literal">String</tt>.</p>
</div>
<div class="section" id="custom-types">
<h3><a class="toc-backref" href="#id14">Custom types</a></h3>
<p>Composite types are particularly useful to store complex set of data. In fact, with Postgresql, defining a table automatically defines the according type. Hydrating type instances with postgresql values are the work of your custom converters. Let's take an example: electrical transformers windings. A transformer winding is defined by the voltage it is supposed to have and the maximum current it can stands. A transformer have two or more windings so if we define a type WindingPower we will be able to store an array of windings in our transformer table:</p>
<pre class="literal-block">-- SQL
CREATE TYPE winding_power AS (
    voltage numeric(4,1),
    current numeric(5,3)
);
</pre>
<p>Tables containing a field with this type will return a tuple. A good way to manipulate that kind of data would be to create a <tt class="docutils literal">WindingPower</tt> type class:</p>
<pre class="literal-block">&lt;?php

namespace Model\Pomm\Type;

class WindingPower
{
    public $voltage;
    public $current;

    public function __construct($voltage, $current)
    {
        $this-&gt;voltage = $voltage;
        $this-&gt;current = $current;
    }

    public getPowerMax()
    {
      return $this-&gt;voltage * $this-&gt;current;
    }
}
</pre>
<p>Here, we can see the very good side of this method: we can implement a <tt class="docutils literal">getPowerMax()</tt> method and make our type richer.</p>
</div>
<div class="section" id="writing-your-own-converters">
<h3><a class="toc-backref" href="#id15">Writing your own converters</a></h3>
<dl class="docutils">
<dt>You can write your own converters for your custom postgresql types. All they have to do is to implement the <tt class="docutils literal">Pomm\Converter\ConverterInterface</tt>. This interface makes your converter to have two methods:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">fromPg($data)</span></tt>: convert data from Postgesql by returning the according PHP structure. The returned value will be hydrated in your entities.</li>
<li><tt class="docutils literal"><span class="pre">toPg($data))</span></tt>: returns a string with the Postgresql representation of a PHP structure. This string will be used in the SQL queries generated by the Map files to save or update entities.</li>
</ul>
</dd>
</dl>
<p>Here is the converter for the <tt class="docutils literal">WindingPower</tt> type mentioned above:</p>
<pre class="literal-block">&lt;?php

namespace Model\Pomm\Converter;

use Pomm\Converter\ConverterInterface;
use Model\Pomm\Type\WindingPower as WindingPowerType;

class WindingPower implements ConverterInterface
{
    protected $class_name;

    public function __contruct($class_name = 'Model\\Pomm\\Type\\WindingPowerType')
    {
        $this-&gt;class_name = $class_name;
    }

    public function fromPg($data, $type = null)
    {
        $data = trim($data, "()");
        $values = preg_split('/,/', $data);

        return new $this-&gt;class_name($values[0], $values[1]);
    }

    public function toPg($data, $type = null)
    {
        return sprintf("winding_power '(%4.1f,%4.3f)'", $data-&gt;voltage, $data-&gt;current);
    }
}
</pre>
<p>Of course you can hardcode the class to be returned by the converter but it prevents others from extending your type.</p>
</div>
<div class="section" id="entity-converter">
<h3><a class="toc-backref" href="#id16">Entity converter</a></h3>
<p>In Postgresql, creating a table means creating a new type with the table's fields definition. Hence, it is possible to use that data type in other tables or use them as objects in your SQL queries. Pomm proposes a special converter to do so: the <tt class="docutils literal">PgEntity</tt> converter. Passing the table data type name and the associated entity class name will grant you with embedded entities.</p>
<pre class="literal-block">class MyDatabase extends Pomm\Connection\Database
{
  protected function initialize()
  {
    parent::initialize();

    $this-&gt;registerConverter('MyEntity',
      new Pomm\Converter\PgEntity(
        $this,
       'Database\Schema\MyEntity'
      ),
      array('my_entity')
    );
  }
}
</pre>
</div>
</div>
</div>
<div class="section" id="entities">
<h1><a class="toc-backref" href="#id17">Entities</a></h1>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id18">Overview</a></h2>
<div class="section" id="what-is-an-entity-class">
<h3><a class="toc-backref" href="#id19">What is an Entity class ?</a></h3>
<p>Entities are what programmers use in the end of the process. They are an OO implementation of the data retrieved from the database. Most of the time, these PHP classes are automatically generated by the instrospection tool (see <a class="reference internal" href="#php-tools">PHP tools</a>) but you can write you own classes by hand. They just have to extends <tt class="docutils literal">Pomm\Object\BaseObject</tt> class to know about status (see <a class="reference internal" href="#life-cycle">Life cycle</a>). Important things to know about entities are <strong>they are schemaless</strong> and <strong>they are data source agnostic</strong>.</p>
<p>By default, entities lie in the same directory than their map classes and de facto share the same namespace but this is only convention.</p>
<pre class="literal-block">&lt;?php

namespace Database\Schema;

use \Pomm\Object\BaseObject;
use \Pomm\Exception\Exception;

class MyEntity extends BaseObject
{
}
</pre>
</div>
<div class="section" id="data-source-agnostic">
<h3><a class="toc-backref" href="#id20">Data source agnostic</a></h3>
<p>Entities do not know anything about database in general. This means they do not know how to save, retrieve or update themselves (see <a class="reference internal" href="#map-classes">Map classes</a> for that). You can use <tt class="docutils literal">BaseObject</tt> children to store data of your web services, NoSQL database etc. They use the <tt class="docutils literal">hydrate()</tt> method to get data and accessors to read / write data from them (see <a class="reference internal" href="#living-with-entities">Living with entities</a> below).</p>
</div>
<div class="section" id="schemaless-entities">
<h3><a class="toc-backref" href="#id21">Schemaless entities</a></h3>
<p>Entities do not know anything about the structure of the tables, views etc. They are just flexible typed containers for data. They use PHP magic methods to simulate getters and setters on data they own (see <a class="reference internal" href="#living-with-entities">Living with entities</a> below). This is very powerful because you can access entities like it is an array an benefit from method overloads.</p>
<!--  -->
<blockquote>
Note that means entities do not know anything about their primary key either.</blockquote>
</div>
</div>
<div class="section" id="living-with-entities">
<h2><a class="toc-backref" href="#id22">Living with entities</a></h2>
<div class="section" id="creator">
<h3><a class="toc-backref" href="#id23">Creator</a></h3>
<p>There are two ways to create entities. Use the constructor or use the <tt class="docutils literal">createObject()</tt> method from its related map class (see <a class="reference internal" href="#map-classes">Map classes</a>).</p>
<pre class="literal-block">$entity = new Database\Schema\MyEntity();

$entity = $database
  -&gt;createConnection()
  -&gt;getMapFor('Database\Schema\MyEntity')
  -&gt;createObject();
</pre>
<p>Both these methods accept an optional array of values that would be hydrated in the entity.</p>
</div>
<div class="section" id="accessors-and-mutators">
<h3><a class="toc-backref" href="#id24">Accessors and mutators</a></h3>
<p>The abstract parent <tt class="docutils literal">BaseObject</tt> uses magic getters and setters to dynamically build the according methods. Internally, all values are stored in an array. The methods <tt class="docutils literal">set()</tt> and <tt class="docutils literal">get()</tt> are the interface to this array:</p>
<pre class="literal-block">$entity = new Database\Schema\MyEntity();
$entity-&gt;has('pika'); // false
$entity-&gt;set('pika', 'chu');
$entity-&gt;has('pika'); // true
$entity-&gt;get('pika'); // chu
</pre>
<p>Note that <tt class="docutils literal">get()</tt> can take an array with multiple attributes:</p>
<pre class="literal-block">$entity-&gt;set('pika', 'chu');
$entity-&gt;set('plop', true);

$entity-&gt;get(array('pika', 'plop')); // returns array('pika' =&gt; 'chu', 'plop' =&gt; true);
$entity-&gt;get($map-&gt;getPrimaryKey()); // returns the primary key if set.
</pre>
<p><tt class="docutils literal">get()</tt> and <tt class="docutils literal">set()</tt> are <strong>generic accessors</strong>. They are used internally and cannot be overloaded. But you can also use <strong>virtual accessors</strong>:</p>
<pre class="literal-block">$entity = new Database\Schema\MyEntity(array('pika' =&gt; 'chu'));
$entity-&gt;getPika();      // chu
</pre>
<p>They are called virtual because they do not exist by default but <tt class="docutils literal">BaseObject</tt> implements the <tt class="docutils literal">__call()</tt> method to trap accessor calls using the <tt class="docutils literal">get()</tt> and <tt class="docutils literal">set()</tt> generic methods. Of course all these can be overloaded:</p>
<pre class="literal-block">// in the Entity class
public function getPika()
{
  return strtoupper($this-&gt;get('pika'));
}

// elsewhere
$entity = new Database\Schema\MyEntity(array('pika' =&gt; 'chu'));
$entity-&gt;getPika();     // CHU
</pre>
<p>The methods <tt class="docutils literal">set()</tt> and <tt class="docutils literal">get()</tt> should be used only if you want to bypass any overload that could exist.</p>
</div>
<div class="section" id="interfaces-and-overloads">
<h3><a class="toc-backref" href="#id25">Interfaces and overloads</a></h3>
<p>Entities implement PHP's <tt class="docutils literal">ArrayAccess</tt> interface to use the accessors if any. This means you can have easy access to your entity's data in your templates without bypassing accessors !</p>
<pre class="literal-block">// in the Entity class
public function getPika()
{
  return strtoupper($this-&gt;get('pika'));
}

// elsewhere
$entity-&gt;setPika('chu');
$entity-&gt;getPika();     // CHU
$entity['pika'];        // CHU
$entity-&gt;pika;          // CHU

$entity-&gt;get('pika');   // chu
</pre>
</div>
<div class="section" id="extending-entities">
<h3><a class="toc-backref" href="#id26">Extending entities</a></h3>
<p>Of course you can extend your entities providing new accessors. If by example you have an entity with a weight in grams and you would like to have an accessor that return it in ounces:</p>
<pre class="literal-block">public function getWeightInOunce()
{
  return round($this-&gt;getWeight() * 0.0352739619, 2);
}
</pre>
<p>In your templates, you can directly benefit from this accessor while using the entity as an array:</p>
<pre class="literal-block">// in PHP
&lt;?php echo $thing['weight_in_ounce'] ?&gt;

// with Twig
{{ thing.weight_in_ounce }}
</pre>
</div>
</div>
<div class="section" id="entities-and-database">
<h2><a class="toc-backref" href="#id27">Entities and database</a></h2>
<div class="section" id="hydrate-and-convert">
<h3><a class="toc-backref" href="#id28">Hydrate and convert</a></h3>
<p>It may happen you need to create objects with data as array. <tt class="docutils literal">Pomm</tt> uses this mechanism internally to hydrate the entities with database values. The <tt class="docutils literal">hydrate()</tt> method takes an array and merge it with the entity's internal values. Be aware PHP associative arrays keys are case sensitive shile postgresql's field names are not. If you need some sort of conversion the <tt class="docutils literal">convert()</tt> method will help. You can overload the <tt class="docutils literal">convert()</tt> method to create a more specific conversion (if you use web services data provider by example) but you cannot overload the <tt class="docutils literal">hydrate()</tt> method.</p>
</div>
<div class="section" id="life-cycle">
<h3><a class="toc-backref" href="#id29">Life cycle</a></h3>
<p>Entities also propose mechanisms to check what state are their data compared to the data source. There are 2 states which present 4 possible combinations:</p>
<dl class="docutils">
<dt><strong>EXIST</strong></dt>
<dd>The instance is fetched from the data source.</dd>
<dt><strong>MODIFIED</strong></dt>
<dd>This instance has been modified with mutators.</dd>
</dl>
<p>So, of course, an entity can be in both states EXIST and MODIFIED or NONE of them. The <tt class="docutils literal">BaseObject</tt> class grants you with several methoods to check this internal state: <tt class="docutils literal">isNew()</tt>, <tt class="docutils literal">isModified()</tt> or you can directly access the <tt class="docutils literal">_state</tt> attribute from within your class definition:</p>
<pre class="literal-block">$entity = $map-&gt;createObject();
$entity-&gt;isNew();           // true
$entity-&gt;isModified();      // false
$entity-&gt;setPika('chu');
$entity-&gt;isNew();           // true
$entity-&gt;isModified();      // true
</pre>
</div>
</div>
</div>
<div class="section" id="map-classes">
<h1><a class="toc-backref" href="#id30">Map classes</a></h1>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id31">Overview</a></h2>
<dl class="docutils">
<dt>Map classes are the central point of Pomm because</dt>
<dd><ul class="first last simple">
<li>they are a bridge between the database and your entities</li>
<li>they own the structure of the entities</li>
<li>They act as entity providers</li>
</ul>
</dd>
</dl>
<p>Every action you will perform with your entities will use a Map class. They are roughly the equivalent of Propel's <em>Peer</em> classes. Although it might look like Propel, it is important to understand unlike the normal Active Record design pattern, entities do not even know their structure and how to save themselves. You have to use their relative Map class to save them.</p>
<p>Map classes represent a structure in the database and provide methods to retrieve and save data with this structure. To be short, one table or view =&gt; one map class.</p>
<p>To create the link between your database and your entities, all Map classes <strong>must</strong> at the end extends <tt class="docutils literal">Pomm\Object\BaseObjectMap</tt>. This class implements methods that directly interact with the database using the PDO layer. These methods will be explained in the chapter <a class="reference internal" href="#querying-the-database">Querying the database</a>.</p>
<dl class="docutils">
<dt>The structure of the map classes can be automatically guessed from the database hence it is possible to generate the structure part of the map files from the command line (see below). If these classes can be generated, it is advisable not to modify them by hand because modifications would be lost at the next generation. This is why Map classes are split using inheritance:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal">BaseYourEntityMap</tt> which are abstract classes inheriting from <tt class="docutils literal">BaseObjectMap</tt></li>
<li><tt class="docutils literal">YourEntityMap</tt> inheriting <tt class="docutils literal">BaseYourEntityMap</tt> which itself inherits from <tt class="docutils literal">Pomm\Object\BaseObjectMap</tt>.</li>
</ul>
</dd>
</dl>
<p><tt class="docutils literal">BaseYourEntityMap</tt> can be skipped but since Pomm proposes automatic code generation, this file can be regenerated over and over without you to loose precious custom code. This is why this file owns the data structure read from the database.</p>
</div>
<div class="section" id="structure">
<h2><a class="toc-backref" href="#id32">Structure</a></h2>
<div class="section" id="introspected-tables">
<h3><a class="toc-backref" href="#id33">Introspected tables</a></h3>
<dl class="docutils">
<dt>When Map classes are instantiated, the method <tt class="docutils literal">initialize</tt> is triggered. This method is responsible of setting various structural elements:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal">object_name</tt>: the related table name</li>
<li><tt class="docutils literal">object_class</tt>: the related entity's fully qualified class name</li>
<li><tt class="docutils literal">field_structure</tt>: the fields with the corresponding converter name</li>
<li><tt class="docutils literal">primary_key</tt>: an array with simple or composite primary key</li>
</ul>
</dd>
</dl>
<p>If the table is stored in a special database schema, it must appear in the <tt class="docutils literal">object_name</tt> attribute. If you do not use schemas, postgresql will store everything in the public schema. You do not have to specify it in the <tt class="docutils literal">object_name</tt> attribute but it will be used in the class namespace. As <tt class="docutils literal">public</tt> is also a reserved keyword of PHP, the namespace for the public schema is <tt class="docutils literal">PublicSchema</tt>.</p>
<p>Let's say we have the following table <tt class="docutils literal">student</tt> in the <tt class="docutils literal">public</tt> schema of the database <tt class="docutils literal">College</tt>:</p>
<pre class="literal-block">+-------------+-------------------------------+
|   Column    |            Type               |
+=============+===============================+
|  reference  | character(10)                 |
+-------------+-------------------------------+
|  first_name | character varying             |
+-------------+-------------------------------+
|  last_name  | character varying             |
+-------------+-------------------------------+
|  birthdate  | timestamp without time zone   |
+-------------+-------------------------------+
|  level      | smallint                      |
+-------------+-------------------------------+
|  exam_dates | timestamp without time zone[] |
+-------------+-------------------------------+
</pre>
<p>The last field <tt class="docutils literal">exam_dates</tt> is an array of timestamps (see <a class="reference internal" href="#arrays">Arrays</a> below). The according generated structure will be:</p>
<pre class="literal-block">&lt;?php

 namespace College\PublicSchema\Base;

 use Pomm\Object\BaseObjectMap;
 use Pomm\Exception\Exception;

 abstract class StudentMap extends BaseObjectMap
 {
     public function initialize()
     {
         $this-&gt;object_class =  'College\PublicSchema\Student';
         $this-&gt;object_name  =  'student';

         $this-&gt;addField('reference', 'char');
         $this-&gt;addField('first_name', 'varchar');
         $this-&gt;addField('last_name', 'varchar');
         $this-&gt;addField('birthdate', 'timestamp');
         $this-&gt;addField('level', 'smallint');
         $this-&gt;addField('exam_dates', 'timestamp[]');

         $this-&gt;pk_fields = array('reference');
     }
 }
</pre>
<p>All generated map classes use PHP namespace. This namespace is composed by the database name and the database schema the table is located in. If database name is not supplied to the <tt class="docutils literal">Database</tt> constructor (see <a class="reference internal" href="#database-class-and-isolation-level">Database class and isolation level</a>), the real database name is used. If by example, the previous table were in the <tt class="docutils literal">school</tt> database schema, the following lines would change:</p>
<pre class="literal-block">&lt;?php

 namespace College\School\Base;
 ...
         $this-&gt;object_class =  'College\School\Student';
         $this-&gt;object_name  =  'school.student';
</pre>
</div>
<div class="section" id="arrays">
<h3><a class="toc-backref" href="#id34">Arrays</a></h3>
<p>Postgresql supports arrays. An array can contain several entities all from the same type. Pomm of course supports this feature using the <tt class="docutils literal">[]</tt> notation after the converter declaration:</p>
<pre class="literal-block">$this-&gt;addField('authors', 'varchar[]');   // Array of strings
$this-&gt;addField('locations', 'point[]');   // Array of points
</pre>
<p>The converter system handles that and the entities will be hydrated with an array of the according type depending on the given converter. Of course, all converters must be registered prior to the declaration.</p>
</div>
<div class="section" id="temporary-tables">
<h3><a class="toc-backref" href="#id35">Temporary tables</a></h3>
<p>Sometimes, you might want to create temporary tables. A map class can create its own table, modify it and destroy it. Let's imagine we have to create a temporary tables for students and their average scores in each discipline. The following map class could do the job:</p>
<pre class="literal-block">&lt;?php

namespace College\School;

use Pomm\Object\BaseObjectMap;
use Pomm\Object\BaseObject;
use Pomm\Query\Where;

class AverageStudentScoreMap extends BaseObjectMap
{
    public function initialize()
    {
      $this-&gt;object_class =  'College\School\AverageStudentScore';
      $this-&gt;object_name  =  'school.average_student_score';

      $this-&gt;addField('reference', 'varchar');
      $this-&gt;addField('maths', 'numeric');
      $this-&gt;addField('physics', 'numeric');
      ...
    }

    public function createTable()
    {
      $sql = "CREATE TEMPORARY TABLE %s (reference VARCHAR PRIMARY KEY, ...

      $this-&gt;query(sprintf($sql, $this-&gt;getTableName()), array());
    }

    public function dropTable()
    {
      $sql = "DROP TABLE %s CASCADE";

      $this-&gt;query(sprintf($sql, $this-&gt;getTableName()), array());
    }
}
</pre>
<p>You can create methods to change the table structure, add or drop columns etc. This is what it is done by example in the converter test script.</p>
</div>
</div>
<div class="section" id="querying-the-database">
<h2><a class="toc-backref" href="#id36">Querying the database</a></h2>
<div class="section" id="create-update-drop">
<h3><a class="toc-backref" href="#id37">Create, update, drop</a></h3>
<p>The main goal of the map classes is to provide a layer between your database and your entities. They provide you with basic tools to save, update and delete your entities trough <tt class="docutils literal">saveOne()</tt>, <tt class="docutils literal">updateOne()</tt> and <tt class="docutils literal">deleteOne()</tt> methods.</p>
<pre class="literal-block">$entity = $map-&gt;createObject(array('pika' =&gt; 'chu', 'plop' =&gt; false));

$map-&gt;saveOne($entity);     // INSERT

$entity-&gt;setPika('no');
$entity-&gt;setPlop(true);

$map-&gt;saveOne($entity);     // UPDATE
</pre>
<p>As illustrated above, the <tt class="docutils literal">saveOne()</tt> method saves your object whatever it is an update or an insert. It is important to know that the internal state (see <a class="reference internal" href="#life-cycle">Life cycle</a>) of the entity is used to determine if the object exists or not and choose between the <tt class="docutils literal">INSERT</tt> or the <tt class="docutils literal">UPDATE</tt> statement.
Whatever is used, the whole structure is saved every time this method is called. In case you do just update some fields you can use the <tt class="docutils literal">updateOne()</tt> method.
Note that if the table related to this entity sets default values (like <tt class="docutils literal">created_at</tt> field by example) they will be <strong>automatically hydrated in the entity</strong>.</p>
<pre class="literal-block">$entity-&gt;setPika('chu');
$entity-&gt;setPlop(false);

$map-&gt;updateOne($entity, array('pika')); // UPDATE ... set pika='...'

$map-&gt;getPika();            // chu
$map-&gt;getPlop();            // true
</pre>
<p>In the example above, two fields are set and only one is updated. The result of this is the second field to be <strong>replaced with the value from the database</strong>.</p>
<pre class="literal-block">$map-&gt;deleteOne($entity);

$entity-&gt;isNew();           // false
$entity-&gt;isModified();        // false
</pre>
<p>The <tt class="docutils literal">deleteOne()</tt> method is pretty straightforward. Like the other modifiers, it hydrates the object with the deleted row from the database in case you want to save it elsewhere.</p>
</div>
<div class="section" id="built-in-finders">
<h3><a class="toc-backref" href="#id38">Built-in finders</a></h3>
<p>The first time you generate the base map classes, it will also generate the map classes and the entity classes. Using the example with student, the empty map file should look like this:</p>
<pre class="literal-block">&lt;?php
namespace College\School;

use College\School\Base\StudentMap as BaseStudentMap;
use Pomm\Exception\Exception;
use Pomm\Query\Where;
use College\School\Student;

class StudentMap extends BaseStudentMap
{
}
</pre>
<p>This is the place you are going to create your own finder methods. As it extends <tt class="docutils literal">BaseObjectMap</tt> via <tt class="docutils literal">BaseStudentMap</tt> it already has some useful finders:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal">findAll()</tt> return all entities</li>
<li><tt class="docutils literal"><span class="pre">findByPK(...)</span></tt> return a single entity</li>
<li><tt class="docutils literal"><span class="pre">findWhere(...)</span></tt> perform a
<tt class="docutils literal">SELECT ... FROM my.table WHERE ...</tt></li>
</ul>
</blockquote>
<p>Finders return either a <tt class="docutils literal">Collection</tt> instance virtually containing all model instances returned by the query (see <a class="reference internal" href="#collections">Collections</a>) or just a related model entity instance (like <tt class="docutils literal">findByPK</tt>).</p>
</div>
<div class="section" id="findwhere">
<h3><a class="toc-backref" href="#id39">findWhere</a></h3>
<p>The simplest way to create a finder with Pomm is to use the <tt class="docutils literal">findWhere()</tt> method.</p>
<dl class="docutils">
<dt>findWhere($where, $values, $suffix)</dt>
<dd>return a set of entities based on the given where clause. This clause can be a string or a <tt class="docutils literal">Where</tt> instance.</dd>
</dl>
<p>It is possible to use it directly because we are in a Map class hence Pomm knows what table and fields to use in the query.</p>
<pre class="literal-block">/* SELECT
     reference,
     first_name,
     last_name,
     birthdate
   FROM
     shool.student
   WHERE
       birthdate &gt; '1980-01-01
     AND
       first_name ILIKE '%an%'
*/

// don't do that !
$students = $this-&gt;findWhere("birthdate &gt; '1980-01-01' AND first_name ILIKE '%an%'");
</pre>
<p>Of course, this is not very useful, because the date is very likely to be a parameter. A finder <tt class="docutils literal">getYoungerThan</tt> would be:</p>
<pre class="literal-block">public function getYoungerThan(DateTime $date)
{
/* SELECT
     reference,
     first_name,
     last_name,
     birthdate
   FROM
     shool.student
   WHERE
       birthdate &gt; $date
     AND
       first_name ILIKE '%an%'
   ORDER BY
     birthdate DESC
   LIMIT 10
*/

  return $this-&gt;findWhere("birthdate &gt; ? AND first_name ILIKE ?",
      array($date-&gt;format('Y-m-d'), '%an%'),
      'ORDER BY birthdate DESC LIMIT 10'
      );
}
</pre>
<p>All queries are prepared, this might increase the performance but it certainly increases the security. Passing the argument using the question mark makes it automatically to be escaped by the database and ovoid SQL-injection attacks. If a suffix is passed, it is appended to the query <strong>as is</strong>. The suffix is intended to allow developers to specify sorting a subset parameters to the query. As the query is prepared, a multiple query injection type attack is not directly possible but be careful if you pass values sent by the customer.</p>
</div>
<div class="section" id="and-or-the-where-class">
<h3><a class="toc-backref" href="#id40">AND OR: The Where class</a></h3>
<p>Sometimes, you do not know in advance what will be the clauses of your query because it depends on variable factors. You can use the <tt class="docutils literal">Where</tt> class to chain logical statements:</p>
<pre class="literal-block">public function getYoungerThan(DateTime $date, $needle)
{
  $where = new Pomm\Query\Where("birthdate &gt; ?", array($date-&gt;format('Y-m-d')));
  $where-&gt;andWhere('first_name ILIKE ?', array(sprintf('%%%s%%', $needle)));

  return $this-&gt;findWhere($where, null, 'ORDER BY birthdate DESC LIMIT 10');
}
</pre>
<p>The <tt class="docutils literal">Where</tt> class has two very handy methods: <tt class="docutils literal">andWhere</tt> and <tt class="docutils literal">orWhere</tt> which can take string or another <tt class="docutils literal">Where</tt> instance as argument. All methods return a <tt class="docutils literal">Where</tt> instance so it is possible to chain the calls. The example above can be rewritten this way:</p>
<pre class="literal-block">public function getYoungerThan(DateTime $date, $needle)
{
  $where = Pomm\Query\Where::create("birthdate &gt; ?", array($date-&gt;format('Y-m-d')))
      -&gt;andWhere('first_name ILIKE ?', array(sprintf('%%%s%%', $needle)))

  return $this-&gt;findWhere($where, null, 'ORDER BY birthdate DESC LIMIT 10');
}
</pre>
<p>Because the <tt class="docutils literal">WHERE something IN <span class="pre">(...)</span></tt> clause needs to declare as many '?' as given parameters, it has its own constructor:</p>
<pre class="literal-block">// SELECT all_fields FROM some_table WHERE station_id IN ( list of ids );

$this-&gt;findWhere(Pomm\Query\Where::createIn("station_id", $array_of_ids))
</pre>
<p>The <tt class="docutils literal">Where</tt> instances can be combined together with respect of the logical precedence:</p>
<pre class="literal-block">$where1 = new Pomm\Query\Where('pika = ?', array('chu'));
$where2 = new Pomm\Query\Where('age &lt; ?', array(18));

$where1-&gt;orWhere($where2);
$where1-&gt;andWhere(Pomm\Query\Where::createIn('other_id', array(1,2,3,5,7,11)));

echo $where1; // (pika = ? OR age &lt; ?) AND other_id IN (?,?,?,?,?,?)
</pre>
</div>
</div>
<div class="section" id="custom-queries">
<h2><a class="toc-backref" href="#id41">Custom queries</a></h2>
<div class="section" id="fields-methods">
<h3><a class="toc-backref" href="#id42">fields methods</a></h3>
<p>Although it is possible to write whole plain queries by hand in the finders, this may induce coupling between your classes and the database structure. To reduce coupling effects, the map class proposes the following methods:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">getSelectFields($alias)</span></tt> return an array with the field names eventually in the form of <tt class="docutils literal">alias.field_name</tt>.</li>
<li><tt class="docutils literal"><span class="pre">getGroupByFields($alias)</span></tt> same as above.</li>
<li><tt class="docutils literal">getFields</tt> used for both methods above.</li>
<li><tt class="docutils literal"><span class="pre">getTableName($alias)</span></tt> return the table name (property object_name see the <a class="reference internal" href="#structure">Structure</a> chapter)</li>
</ul>
<p>Overloading one of these methods will modify the behavior of all built-in finders and those which use them.</p>
<pre class="literal-block">// MyDatabase\Blog\PostMap Class
public function getBlogPostsWithCommentCount(Pomm\Query\Where $where)
{
  $sql = &lt;&lt;&lt;_
  SELECT
    %s,
    COUNT(c.id) as "comment_count"
  FROM
    %s
      LEFT JOIN %s ON
          p.id = c.p_id
  WHERE
      %s
  GROUP BY
      %s
  _;

  $select_fields = join(', ', $this-&gt;getSelectFields('p'));
  $local_table = $this-&gt;getTableName('p');
  $remote_table = $this-&gt;connection-&gt;getMapFor('MyDatabase\Blog\Comment')-&gt;getTableName('c');
  $group_fields = join(', ', $this-&gt;getGroupByFields('p'));

  $sql = sprintf($sql, $select_fields, $local_table, $remote_table, $where, $group_fields);

  return $this-&gt;query($sql, $where-&gt;getValues());
}
</pre>
<p>The <tt class="docutils literal">query()</tt> method is available for your custom queries. It takes 2 parameters, the SQL statement and an optional array of values to be escaped. Keep in mind, the number of values must match the '?' Occurrences in the query.</p>
<p>Whatever you are retrieving, Pomm will hydrate objects according to what is in structure definition of your map class. <strong>Entities do not know about their structure</strong> they just contain data and methods. The entity instances returned here will have this extra field "comment_count" exactly as it would be a normal field. Of course if you update this entity in the database, this field will be ignored.</p>
<p>Sometimes, you want to change the fields list of an entity, by example showing the age of any student. This can be done simply by overloading the <tt class="docutils literal">getSelectFields()</tt> method in your map class:</p>
<pre class="literal-block">public function getSelectFields($alias = null)
{
    $fields = parent::getSelectFields($alias);
    $fields[] = sprintf('age(%sbirthday) AS age',
        is_null($alias) ? '' : $alias.'.');

    return $fields;
}
</pre>
<p>But you can also choose not to retrieve some columns by filtering the fields (like columns containing passwords by example). Be aware that <tt class="docutils literal">getSelectFields()</tt> changes is used in the <tt class="docutils literal">SELECT</tt> part but does not change the <tt class="docutils literal">GROUP BY</tt>. If your queries need both to be updated in the same time, overload the <tt class="docutils literal">getFields()</tt> method.</p>
</div>
<div class="section" id="virtual-fields">
<h3><a class="toc-backref" href="#id43">Virtual fields</a></h3>
<p>As soon as tables have their own data type, they can be considered as plain objects and fetched as is:</p>
<pre class="literal-block">SELECT author FROM author;
|      author       |
+-------------------+
| "(1,'john doe')"  |
+-------------------+
| "(2,'Edgar')"     |
+-------------------+
</pre>
<p>Pomm takes advantage of this feature using <em>virtual fields</em>. You can add fields to your select queries and tie them with a registered converter. If this converter is an entity converter the Pomm model instance will be fetched directly from the query. The example below creates a relationship between the author and the post tables getting all the posts from one author in an array of Post instances:</p>
<pre class="literal-block">// YourDb\SchemaName\AuthorMap

public function getOneWithPosts($author_name)
{
    $remote_map = $this-&gt;connection-&gt;getMapFor('YourDb\SchemaName\Post');

    $sql = &lt;&lt;&lt;_
    SELECT
      %s,
      array_agg(post) AS posts
    FROM
      %s
        LEFT JOIN %s ON
            author.id = post.author_id
    WHERE
        author.name = ?
    GROUP BY
      %s
    _;

    $sql = sprintf($sql,
        join(', ', $this-&gt;getSelectFields('author')),
        $this-&gt;getTableName('author'),
        $remote_map-&gt;getTableName('post'),
        $this-&gt;getGroupByFields('author')
        );

    $this-&gt;addVirtualField('posts', 'schema_name.post[]');

    return $this-&gt;query($sql, array($author_name));
}
</pre>
<p>In this example we assume the <tt class="docutils literal">schema_name.post</tt> type has already been associated with the <tt class="docutils literal">PgEntity</tt> converter with its map class (see <a class="reference internal" href="#entity-converter">Entity converter</a>). The fetched <tt class="docutils literal">Author</tt> instances will have an extra attribute <tt class="docutils literal">posts</tt> containing an array of <tt class="docutils literal">Post</tt> instances (see <a class="reference internal" href="#arrays">Arrays</a>). This is a very powerful feature because you can fetch directly any entity's related objects from the database and hydrate them on the fly.</p>
</div>
</div>
<div class="section" id="collections">
<h2><a class="toc-backref" href="#id44">Collections</a></h2>
<div class="section" id="fetching-results">
<h3><a class="toc-backref" href="#id45">fetching results</a></h3>
<p>The <tt class="docutils literal">query()</tt> method return a <tt class="docutils literal">Collection</tt> instance that holds the PDOStatement with the results. The <tt class="docutils literal">Collection</tt> class implements the <tt class="docutils literal">Coutable</tt> and <tt class="docutils literal">Iterator</tt> interfaces so you can foreach on a Collection to retrieve the results:</p>
<pre class="literal-block">printf("Your search returned '%d' results.", $collection-&gt;count());

foreach($collection as $blog_post)
{
  printf("Blog post '%s' posted on '%s' by '%s'.",
      $blog_post['title'],
      $blog_post['created_at']-&gt;format('Y-m-d'),
      $blog_post['author']
      );
}
</pre>
<p>Sometimes, you want to access a particular result in a collection knowing the result's index. It is possible using the <tt class="docutils literal">has()</tt> and <tt class="docutils literal">get()</tt> methods:</p>
<pre class="literal-block"># Get the an object from the collection at a given index
# or create a new one
if index does not exist
$object = $collection-&gt;has($index) ?
  $collection-&gt;get($index) :
  new Object();
</pre>
<dl class="docutils">
<dt>Collections have other handful methods like:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal">isFirst()</tt></li>
<li><tt class="docutils literal">isLast()</tt></li>
<li><tt class="docutils literal">isEmpty()</tt></li>
<li><tt class="docutils literal">isOdd()</tt></li>
<li><tt class="docutils literal">isEven()</tt></li>
<li><tt class="docutils literal">getOddEven()</tt></li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="collection-filters">
<h3><a class="toc-backref" href="#id46">Collection filters</a></h3>
<p>Pomm's collection class can register filters. Filters are just functions that are executed after values were fetched from the database and before the object is hydrated with them. These filters take the array of fetched values as parameter. They return an array with values which are then given to the next filter and so on. After all filters are being executed, the values are then used to hydrate the object instance related the map the collection comes from.</p>
<pre class="literal-block">$collection = $this-&gt;query($sql, $values);

$collection-&gt;registerFilter(function($values) {
    $values['good_pika'] = $values['pika'] == 'chu' ? 'Good' : 'Try again';

    return $values;
    });
</pre>
<p>The code above register a filter that create an extra field in our result set. Every time a result is fetched, this anonymous function will be triggered and the resulting values will be hydrated in the entity.</p>
</div>
</div>
<div class="section" id="pagers">
<h2><a class="toc-backref" href="#id47">Pagers</a></h2>
<div class="section" id="pager-query-methods">
<h3><a class="toc-backref" href="#id48">Pager query methods</a></h3>
<p><tt class="docutils literal">BaseObjectMap</tt> instances provide 2 methods that will grant you with a <tt class="docutils literal">Pager</tt> class. <tt class="docutils literal">paginateQuery()</tt> and the handy <tt class="docutils literal">paginateFindWhere()</tt>. It adds the correct subset limitation at the end of you query. Of course, it assumes you do not specify any LIMIT nor OFFSET sql clauses in your query.</p>
<p>The <tt class="docutils literal">paginateFindWhere()</tt> method acts pretty much like the <tt class="docutils literal">findWhere()</tt> method (see <a class="reference internal" href="#built-in-finders">Built-in finders</a>) which it uses internally. This means the condition can be either a string or a <tt class="docutils literal">Pomm\Query\Where</tt> instance (see <a class="reference internal" href="#and-or-the-where-class">AND OR: The Where class</a>):</p>
<pre class="literal-block">$pager = $student_map
  -&gt;paginateFindWhere('age &lt; ? OR gender = ?', array(19, 'F'), 'ORDER BY score ASC', 25, 4);
</pre>
<p>The example below ask Pomm to retrieve the fourth page of students that match some condition with 25 results per page.</p>
<p>The <tt class="docutils literal">paginateQuery()</tt> acts like the <tt class="docutils literal">query()</tt> method but you need to provide 2 SQL queries: the one that returns results and the one that counts the total number of rows that first query would return without paging.</p>
</div>
<div class="section" id="displaying-a-pager">
<h3><a class="toc-backref" href="#id49">Displaying a pager</a></h3>
<p><tt class="docutils literal">Pager</tt> instances come with methods to display basic page informations like page count, current page, first result row etc. Here is an example of how to display a page in a twig template:</p>
<pre class="literal-block">&lt;ul&gt;
  {% for student in pager.getCollection() %}
    &lt;li&gt;{{ student }}&lt;/li&gt;
  {% endfor %}
&lt;/ul&gt;
{% if pager.getLastPage() &gt; 1 %}
&lt;div class="pager"&gt;&lt;p&gt;
&lt;a href="{{ app.url_generator.generate('news') }}"&gt;First&lt;/a&gt;
{% if pager.isPreviousPage() %}
&lt;a href="{{ app.url_generator.generate('news', {'page': pager.getPage - 1}) }}"&gt;Previous&lt;/a&gt;
{% else %}
Previous
{% endif %}
News {{ pager.getResultMin() }} to {{ pager.getResultMax() }}
{% if pager.isNextPage() %}
&lt;a href="{{ app.url_generator.generate('news', {'page': pager.getPage + 1} ) }}"&gt;Next&lt;/a&gt;
{% else %}
Next
{% endif %}
&lt;a href="{{ app.url_generator.generate('news', {'page': pager.getLastPage} ) }}"&gt;Last&lt;/a&gt;
&lt;/p&gt;&lt;/div&gt;
{% endif %}
</pre>
</div>
</div>
</div>
<div class="section" id="connections">
<h1><a class="toc-backref" href="#id50">Connections</a></h1>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id51">Overview</a></h2>
<div class="section" id="map-classes-provider">
<h3><a class="toc-backref" href="#id52">Map classes provider</a></h3>
<dl class="docutils">
<dt>As soon as you have a database instance, you can create new connections. This is done by using the <tt class="docutils literal">createConnection()</tt> method. Connections are the way to</dt>
<dd><ul class="first last simple">
<li>Retrieve map classes instances</li>
<li>Manage transactions</li>
</ul>
</dd>
</dl>
<p>The entities are stored in a particular database. This is why only connections to this base are able to give you associated map classes:</p>
<pre class="literal-block">$map = $service-&gt;getDatabase()-&gt;createConnection()
  -&gt;getMapFor('College\School\Student');
</pre>
</div>
<div class="section" id="identity-mappers">
<h3><a class="toc-backref" href="#id53">Identity mappers</a></h3>
<dl class="docutils">
<dt>Connections are also the way to tell the map classes to use or not an <tt class="docutils literal">IdentityMapper</tt>. An indentity mapper is an index kept by the connection and shared amongst the map instances. This index ensures that if an object is retrieved twice from the database, the same <tt class="docutils literal">Object</tt> instance will be returned. This is a very powerful (and dangerous) feature. There are two ways to declare an identity mapper to your connections:</dt>
<dd><ul class="first simple">
<li>in the <tt class="docutils literal">Database</tt> parameters. All the connections created for this database will use the given <tt class="docutils literal">IdentityMapper</tt> class.</li>
<li>when instanciating the connection through the <tt class="docutils literal">createConnection()</tt> call. This enforces the parameter given to the <tt class="docutils literal">Database</tt> class if any.</li>
</ul>
<pre class="last literal-block">$map = $service-&gt;getDatabase()
  -&gt;createConnection(new \Pomm\Identity\IdentityMapperSmart())
  -&gt;getMapFor('College\School\Student');

$student1 = $map-&gt;findByPK(array('id' =&gt; 3));
$student2 = $map-&gt;findByPK(array('id' =&gt; 3));

$student1-&gt;setName('plop');
echo $student2-&gt;getName();    // plop
</pre>
</dd>
<dt>It is often a good idea to have an identity mapper by default, but in some cases you will want to switch it off and ensure all objects you fetch from the database do not come from the mapper. This is possible passing the <tt class="docutils literal">Connection</tt> an instance of <tt class="docutils literal">IdentityMapperNone</tt>. It will never keep any instances. There are two other types of identity mappers:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal">IdentityMapperStrict</tt> which always return an instance if it is in the index.</li>
<li><tt class="docutils literal">IdentityMapperSmart</tt> which checks if the instance has not been deleted. If data are fetched from the db, it checks if the instance kept in the index has not been modified. If not, it merges the fetched values with its instance.</li>
</ul>
</dd>
</dl>
<p>It is of course always possible to remove an instance from the mapper by calling the <tt class="docutils literal">removeInstance()</tt>. You can create your own identity mapper, just make sure your class implement the <tt class="docutils literal">IdentityMapperInterface</tt>. Be aware the mapper is called for each values fetched from the database so it has a real impact on performances.</p>
<p><strong>Important</strong> The identity mappers strict and smart rely on the use of primary keys to identify records. If you use a table without primary keys, these identity mappers will <strong>NOT</strong> store any of these entities.</p>
</div>
</div>
<div class="section" id="transactions">
<h2><a class="toc-backref" href="#id54">Transactions</a></h2>
<div class="section" id="standard-transactions">
<h3><a class="toc-backref" href="#id55">Standard transactions</a></h3>
<p>By default, connections are in auto-commit mode which means every change in the database is committed on the fly. Connections offer the way to enter in a transaction mode:</p>
<pre class="literal-block">$cnx = $service-&gt;getDatabase()
  -&gt;createConnection();
$cnx-&gt;begin();
try {
  # do things here
  $cnx-&gt;commit();
} catch (Pomm\Exception\Exception $e) {
  $cnx-&gt;rollback();
}
</pre>
<p>The transaction type is determined by <tt class="docutils literal">ISOLATION LEVEL</tt> you set in your connection's parameters (see <a class="reference internal" href="#database-class-and-isolation-level">Database class and isolation level</a>)</p>
<p>Isolation level must be one of <tt class="docutils literal"><span class="pre">Pomm\Connection\Connection::ISOLATION_READ_COMMITTED</span></tt>, <tt class="docutils literal">ISOLATION_READ_REPEATABLE</tt> or <tt class="docutils literal">ISOLATION_SERIALIZABLE</tt>. Check your Postgresql version for the available levels. Starting from pg 9.1, what was called <tt class="docutils literal">SERIALIZABLE</tt> is called <tt class="docutils literal">READ_REPEATABLE</tt> and <tt class="docutils literal">SERIALIZABLE</tt> is a race for the first transaction to COMMIT. This means if the transaction fails, you may just try again until it works. Check the <a class="reference external" href="http://www.postgresql.org/docs/9.1/static/transaction-iso.html">postgresql documentation</a> about transactions for details.</p>
</div>
<div class="section" id="partial-transactions-and-savepoints">
<h3><a class="toc-backref" href="#id56">Partial transactions and savepoints</a></h3>
<p>Sometime, you may need to split transactions into parts and be able to perform partial rollback. Postgresql lets you use save points in your transaction:</p>
<pre class="literal-block">$cnx-&gt;begin();
try {
  # do things here
} catch (Pomm\Exception\Exception $e) {
  // The whole transaction is rolled back
  $cnx-&gt;rollback();
  exit;
}
$cnx-&gt;setSavepoint('A');
try {
  # do other things
} catch (Pomm\Exception\Exception $e) {
// only statments after savepoint A are rolled back
  $cnx-&gt;rollback('A');
}
$cnx-&gt;commit();
</pre>
</div>
</div>
<div class="section" id="query-filter-chain">
<h2><a class="toc-backref" href="#id57">Query filter chain</a></h2>
<div class="section" id="loggerfilterchain">
<h3><a class="toc-backref" href="#id58">LoggerFilterChain</a></h3>
<p>The Connection class also holds and the heart of Pomm's query system: the <tt class="docutils literal">QueryFilterChain</tt>. The filter chain is an ordered stack of filters which can be executed. As the first filter is executed it can call the following filter. The code before the next filter call will be executed before and the code placed after will be run after.
This mechanism aims at wrapping the query system with tools like loggers or event systems. It is also possible to bypass completely the query execution as long as you return a <tt class="docutils literal">PDOStatement</tt> instance.</p>
<pre class="literal-block">$database = new Pomm\Connection\Database(array('dsn' =&gt; 'pgsql://user/database'));
$logger = new Pomm\Tools\Logger();

$connection = $database-&gt;createConnection();
$connection-&gt;registerFilter(new Pomm\FilterChain\LoggerFilter($logger));

$students = $connection
  -&gt;getMapFor('MyDb\School\Student')
  -&gt;findWhere('age &gt; ?', array(18), 'ORDER BY level DESC');

$logger-&gt;getLogs()
/* Array(
     "1327047962.9422" =&gt; Array(
       'sql'       =&gt; 'SELECT ... FROM school.student WHERE age &gt; ? ORDER BY level DESC',
       'params'    =&gt; array(18),
       'duration'  =&gt; 0.003079,
       'results'   =&gt; 23
     ))
 */
</pre>
</div>
<div class="section" id="writing-a-filter">
<h3><a class="toc-backref" href="#id59">Writing a Filter</a></h3>
<p>Writing a filter is very easy, it just must implement the <tt class="docutils literal">FilterInterface</tt>.</p>
<pre class="literal-block">class MyFilter implements \Pomm\Filter\FilterInterface
{
    public function execute(\Pomm\Filter\QueryFilterChain $query_filter_chain)
    {
        // Do something before the query is executed

        // Call the next filter
        // If you do not, the query will never be executed.
        // Be sure to return a PDOStatement or throw an Exception.
        $stmt = $query_filter_chain-&gt;executeNext($query_filter_chain);

        // Do something after the query is executed

        return $stmt;
    }
}
</pre>
<p>You can register as many filters as you want but keep in mind filters are executed for every single query so it may slow down dramatically your application.</p>
</div>
</div>
</div>
<div class="section" id="tools">
<h1><a class="toc-backref" href="#id60">Tools</a></h1>
<div class="section" id="php-tools">
<h2><a class="toc-backref" href="#id61">PHP tools</a></h2>
<p>Pomm comes with <tt class="docutils literal">Tools</tt> classes to assist the user in some common tasks. The most used tool is the <tt class="docutils literal">BaseMap</tt> classes generation from database inspection. Here is a way you can use this tool to generate all the model files based on the database structure:</p>
<pre class="literal-block">&lt;?php

require __DIR__.'/vendor/pomm/test/autoload.php';

$service = new Pomm\Service(array(
    'default' =&gt; array(
        'dsn' =&gt; 'pgsql://nss_user:nss_password@localhost/nss_db'
)));

$scan = new Pomm\Tools\ScanSchemaTool(array(
    'dir'=&gt; __DIR__,
    'schema' =&gt; 'transfo',
    'database' =&gt; $service-&gt;getDatabase(),
));

$scan-&gt;execute();
</pre>
<p>This will parse the postgresql's schema named <em>transfo</em> to scan it for tables and views. Then it will generate automatically the <em>BaseMap</em> files with the class structure and if map files or entity files do not exist, will create them.</p>
</div>
<div class="section" id="database-tools">
<h2><a class="toc-backref" href="#id62">Database tools</a></h2>
<p>Pomm comes with a handy set of SQL tools. These functions are coded with PlPgsql so need that language to be created in the database.</p>
<dl class="docutils">
<dt>is_email(varchar)</dt>
<dd>This function returns true if the parameter is a valid email and false otherwise</dd>
<dt>is_url(varchar)</dt>
<dd>This function returns true if the parameter is a valid url and false otherwise</dd>
<dt>transliterate(varchar)</dt>
<dd>This function replace all accentuated characters by non accentuated Latin equivalent.</dd>
<dt>slugify(varchar)</dt>
<dd>This returns the given string but transliterated, lowered, and all non alphanumerical characters replaced by a dash. This is useful to create meaningful urls.</dd>
<dt>cut_nicely(varchar, length)</dt>
<dd>This function cut a string after a certain length but only on non alphanumerical characters not to cut words.</dd>
<dt>array_merge(anyelement[], anyelement[])</dt>
<dd>Return the merge of both arrays but similar values are present only once in the result.</dd>
<dt>update_updated_at</dt>
<dd>This is for triggers to keep the <tt class="docutils literal">updated_at</tt> fields updated.</dd>
</dl>
</div>
</div>
</div>


</body></html>
